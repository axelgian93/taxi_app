/* tslint:disable */
/* eslint-disable */
/**
 * Taxi API
 * API de Taxi
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AdminDiagnosticsMatching200Response {
    'postgisAvailable'?: boolean;
    'env'?: AdminDiagnosticsMatching200ResponseEnv;
    'counters'?: { [key: string]: number; };
}
export interface AdminDiagnosticsMatching200ResponseEnv {
    'MATCH_RADIUS_M'?: number;
    'LOCATION_MAX_AGE_MIN'?: number;
}
export interface AdminRefundsList200Response {
    'items'?: Array<PaymentsRefundsByTrip200ResponseItemsInner>;
    'nextCursor'?: string;
}
export interface AdminTariffsCreateRequest {
    'city': string;
    'active'?: boolean;
    'baseFareUsd': number;
    'perKmUsd': number;
    'perMinUsd': number;
    'minFareUsd'?: number;
    'nightMultiplier'?: number;
    'weekendMultiplier'?: number;
    'surgeMultiplier'?: number;
    'nightStartHour'?: number;
    'nightEndHour'?: number;
    'cancellationGraceSec'?: number;
    'cancellationFeeAcceptedUsd'?: number;
    'cancellationFeeArrivedUsd'?: number;
    'notes'?: string;
    /**
     * Si true, desactiva reglas activas previas de la misma ciudad
     */
    'deactivateOld'?: boolean;
}
export interface AdminTariffsList200Response {
    'items'?: Array<AdminTariffsList200ResponseItemsInner>;
}
export interface AdminTariffsList200ResponseItemsInner {
    'id'?: string;
    'city'?: string;
    'active'?: boolean;
    'baseFareUsd'?: number;
    'perKmUsd'?: number;
    'perMinUsd'?: number;
    'minFareUsd'?: number;
    'nightMultiplier'?: number;
    'weekendMultiplier'?: number;
    'surgeMultiplier'?: number;
    'nightStartHour'?: number;
    'nightEndHour'?: number;
    'cancellationGraceSec'?: number;
    'cancellationFeeAcceptedUsd'?: number;
    'cancellationFeeArrivedUsd'?: number;
    'validFrom'?: string;
    'validTo'?: string;
    'notes'?: string;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface AdminTariffsUpdateByIdRequest {
    'city'?: string;
    'active'?: boolean;
    'baseFareUsd'?: number;
    'perKmUsd'?: number;
    'perMinUsd'?: number;
    'minFareUsd'?: number;
    'nightMultiplier'?: number;
    'weekendMultiplier'?: number;
    'surgeMultiplier'?: number;
    'nightStartHour'?: number;
    'nightEndHour'?: number;
    'cancellationGraceSec'?: number;
    'cancellationFeeAcceptedUsd'?: number;
    'cancellationFeeArrivedUsd'?: number;
    'notes'?: string;
    /**
     * Si true, desactiva reglas activas previas de la misma ciudad
     */
    'deactivateOld'?: boolean;
}
export interface AdminTripsList200Response {
    'items'?: Array<AdminTripsList200ResponseItemsInner>;
    'nextCursor'?: string;
}
export interface AdminTripsList200ResponseItemsInner {
    'id'?: string;
    'status'?: string;
    'riderId'?: string;
    'driverId'?: string;
    'requestedAt'?: string;
    'completedAt'?: string;
    'costUsd'?: number;
    'currency'?: string;
}
export interface AuthLoginRequest {
    'email': string;
    'password': string;
}
export interface AuthMe200Response {
    'user'?: AuthMe200ResponseUser;
}
export interface AuthMe200ResponseUser {
    'id'?: string;
    'email'?: string;
    'role'?: AuthMe200ResponseUserRoleEnum;
    'firstName'?: string;
    'lastName'?: string;
}

export const AuthMe200ResponseUserRoleEnum = {
    Admin: 'ADMIN',
    Driver: 'DRIVER',
    Rider: 'RIDER'
} as const;

export type AuthMe200ResponseUserRoleEnum = typeof AuthMe200ResponseUserRoleEnum[keyof typeof AuthMe200ResponseUserRoleEnum];

export interface AuthRegister201Response {
    'token'?: string;
    'user'?: AuthRegister201ResponseUser;
}
export interface AuthRegister201ResponseUser {
    'id'?: string;
    'email'?: string;
    'role'?: AuthRegister201ResponseUserRoleEnum;
}

export const AuthRegister201ResponseUserRoleEnum = {
    Admin: 'ADMIN',
    Driver: 'DRIVER',
    Rider: 'RIDER'
} as const;

export type AuthRegister201ResponseUserRoleEnum = typeof AuthRegister201ResponseUserRoleEnum[keyof typeof AuthRegister201ResponseUserRoleEnum];

export interface AuthRegister400Response {
    'error'?: string;
}
export interface AuthRegisterRequest {
    'email': string;
    'password': string;
    'firstName': string;
    'lastName': string;
    'role': AuthRegisterRequestRoleEnum;
}

export const AuthRegisterRequestRoleEnum = {
    Admin: 'ADMIN',
    Driver: 'DRIVER',
    Rider: 'RIDER'
} as const;

export type AuthRegisterRequestRoleEnum = typeof AuthRegisterRequestRoleEnum[keyof typeof AuthRegisterRequestRoleEnum];

export interface DriverUpdateStatus200Response {
    'ok'?: boolean;
}
export interface DriverUpdateStatusRequest {
    'lat'?: number;
    'lng'?: number;
    'status'?: DriverUpdateStatusRequestStatusEnum;
}

export const DriverUpdateStatusRequestStatusEnum = {
    Idle: 'IDLE',
    Assigned: 'ASSIGNED',
    Arrived: 'ARRIVED',
    OnTrip: 'ON_TRIP',
    Offline: 'OFFLINE'
} as const;

export type DriverUpdateStatusRequestStatusEnum = typeof DriverUpdateStatusRequestStatusEnum[keyof typeof DriverUpdateStatusRequestStatusEnum];

export interface PaymentsCreateSetupIntent200Response {
    'clientSecret'?: string;
}
export interface PaymentsList200Response {
    'items'?: Array<PaymentsList200ResponseItemsInner>;
    'nextCursor'?: string;
}
export interface PaymentsList200ResponseItemsInner {
    'id'?: string;
    'tripId'?: string;
    'amountUsd'?: number;
    'status'?: PaymentsList200ResponseItemsInnerStatusEnum;
    'method'?: string;
    'provider'?: string;
    'externalId'?: string;
    'createdAt'?: string;
    'updatedAt'?: string;
    'isAuthorized'?: boolean;
    'isPaid'?: boolean;
    'isFailed'?: boolean;
    'providerDisplay'?: string;
    'capturable'?: boolean;
}

export const PaymentsList200ResponseItemsInnerStatusEnum = {
    Pending: 'PENDING',
    Authorized: 'AUTHORIZED',
    Paid: 'PAID',
    Failed: 'FAILED',
    Refunded: 'REFUNDED'
} as const;

export type PaymentsList200ResponseItemsInnerStatusEnum = typeof PaymentsList200ResponseItemsInnerStatusEnum[keyof typeof PaymentsList200ResponseItemsInnerStatusEnum];

export interface PaymentsReceiptByTrip200Response {
    'tripId'?: string;
    'amountUsd'?: number;
    'currency'?: string;
    'method'?: string;
    'status'?: string;
    'provider'?: string;
    'type'?: PaymentsReceiptByTrip200ResponseTypeEnum;
    'paidAt'?: string;
}

export const PaymentsReceiptByTrip200ResponseTypeEnum = {
    Trip: 'TRIP',
    CancellationFee: 'CANCELLATION_FEE'
} as const;

export type PaymentsReceiptByTrip200ResponseTypeEnum = typeof PaymentsReceiptByTrip200ResponseTypeEnum[keyof typeof PaymentsReceiptByTrip200ResponseTypeEnum];

export interface PaymentsRefundByTripRequest {
    'amountUsd'?: number;
    'reason'?: string;
}
export interface PaymentsRefundsByTrip200Response {
    'items'?: Array<PaymentsRefundsByTrip200ResponseItemsInner>;
}
export interface PaymentsRefundsByTrip200ResponseItemsInner {
    'id'?: string;
    'paymentId'?: string;
    'tripId'?: string;
    'amountUsd'?: number;
    'reason'?: string;
    'provider'?: string;
    'externalId'?: string;
    'createdAt'?: string;
}
export interface PaymentsSetDefaultMethodRequest {
    'paymentMethodId': string;
}
export interface TripsCancelRequest {
    'reason'?: string;
}
export interface TripsRequest200Response {
    'ok'?: boolean;
    'trip'?: TripsRequest200ResponseTrip;
}
export interface TripsRequest200ResponseTrip {
    'id'?: string;
    'status'?: TripsRequest200ResponseTripStatusEnum;
}

export const TripsRequest200ResponseTripStatusEnum = {
    Assigned: 'ASSIGNED',
    Accepted: 'ACCEPTED',
    Arrived: 'ARRIVED',
    Ongoing: 'ONGOING',
    Completed: 'COMPLETED',
    Canceled: 'CANCELED'
} as const;

export type TripsRequest200ResponseTripStatusEnum = typeof TripsRequest200ResponseTripStatusEnum[keyof typeof TripsRequest200ResponseTripStatusEnum];

export interface TripsRequestRequest {
    'city': string;
    'pickupLat': number;
    'pickupLng': number;
    'dropoffLat': number;
    'dropoffLng': number;
    'pickupAddress'?: string;
    'dropoffAddress'?: string;
    'distanceKm': number;
    'durationMin': number;
}
export interface UsersRegisterPushToken200Response {
    'ok'?: boolean;
}
export interface UsersRegisterPushTokenRequest {
    'fcmToken': string;
}

/**
 * AdminApi - axios parameter creator
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Estado de PostGIS y parÃ¡metros de matching (env) + contadores de uso.
         * @summary Diagnostics matching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDiagnosticsMatching: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/diagnostics/matching`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exposición de métricas en formato Prometheus. Protegido por rol ADMIN.
         * @summary Prometheus metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminMetrics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crea una regla y opcionalmente desactiva reglas activas previas de la misma ciudad.
         * @summary Crear TariffRule
         * @param {AdminTariffsCreateRequest} adminTariffsCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTariffsCreate: async (adminTariffsCreateRequest: AdminTariffsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminTariffsCreateRequest' is not null or undefined
            assertParamExists('adminTariffsCreate', 'adminTariffsCreateRequest', adminTariffsCreateRequest)
            const localVarPath = `/admin/tariffs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminTariffsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lista reglas por ciudad.
         * @summary Listar TariffRule
         * @param {string} [city] 
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTariffsList: async (city?: string, active?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/tariffs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Actualiza campos de una regla por id.
         * @summary Actualizar TariffRule
         * @param {string} id 
         * @param {AdminTariffsUpdateByIdRequest} [adminTariffsUpdateByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTariffsUpdateById: async (id: string, adminTariffsUpdateByIdRequest?: AdminTariffsUpdateByIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminTariffsUpdateById', 'id', id)
            const localVarPath = `/admin/tariffs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminTariffsUpdateByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTripsList: async (limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/trips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint para scraping por Prometheus. Requiere header x-metrics-token si METRICS_TOKEN está definido o si METRICS_PUBLIC=false.
         * @summary Prometheus metrics (public)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsPublic: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Estado de PostGIS y parÃ¡metros de matching (env) + contadores de uso.
         * @summary Diagnostics matching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDiagnosticsMatching(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminDiagnosticsMatching200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDiagnosticsMatching(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminDiagnosticsMatching']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exposición de métricas en formato Prometheus. Protegido por rol ADMIN.
         * @summary Prometheus metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminMetrics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminMetrics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Crea una regla y opcionalmente desactiva reglas activas previas de la misma ciudad.
         * @summary Crear TariffRule
         * @param {AdminTariffsCreateRequest} adminTariffsCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminTariffsCreate(adminTariffsCreateRequest: AdminTariffsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminTariffsList200ResponseItemsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminTariffsCreate(adminTariffsCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminTariffsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lista reglas por ciudad.
         * @summary Listar TariffRule
         * @param {string} [city] 
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminTariffsList(city?: string, active?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminTariffsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminTariffsList(city, active, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminTariffsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Actualiza campos de una regla por id.
         * @summary Actualizar TariffRule
         * @param {string} id 
         * @param {AdminTariffsUpdateByIdRequest} [adminTariffsUpdateByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminTariffsUpdateById(id: string, adminTariffsUpdateByIdRequest?: AdminTariffsUpdateByIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminTariffsList200ResponseItemsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminTariffsUpdateById(id, adminTariffsUpdateByIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminTariffsUpdateById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminTripsList(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminTripsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminTripsList(limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminTripsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint para scraping por Prometheus. Requiere header x-metrics-token si METRICS_TOKEN está definido o si METRICS_PUBLIC=false.
         * @summary Prometheus metrics (public)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsPublic(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsPublic(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.metricsPublic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Estado de PostGIS y parÃ¡metros de matching (env) + contadores de uso.
         * @summary Diagnostics matching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDiagnosticsMatching(options?: RawAxiosRequestConfig): AxiosPromise<AdminDiagnosticsMatching200Response> {
            return localVarFp.adminDiagnosticsMatching(options).then((request) => request(axios, basePath));
        },
        /**
         * Exposición de métricas en formato Prometheus. Protegido por rol ADMIN.
         * @summary Prometheus metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminMetrics(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adminMetrics(options).then((request) => request(axios, basePath));
        },
        /**
         * Crea una regla y opcionalmente desactiva reglas activas previas de la misma ciudad.
         * @summary Crear TariffRule
         * @param {AdminTariffsCreateRequest} adminTariffsCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTariffsCreate(adminTariffsCreateRequest: AdminTariffsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminTariffsList200ResponseItemsInner> {
            return localVarFp.adminTariffsCreate(adminTariffsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Lista reglas por ciudad.
         * @summary Listar TariffRule
         * @param {string} [city] 
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTariffsList(city?: string, active?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<AdminTariffsList200Response> {
            return localVarFp.adminTariffsList(city, active, options).then((request) => request(axios, basePath));
        },
        /**
         * Actualiza campos de una regla por id.
         * @summary Actualizar TariffRule
         * @param {string} id 
         * @param {AdminTariffsUpdateByIdRequest} [adminTariffsUpdateByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTariffsUpdateById(id: string, adminTariffsUpdateByIdRequest?: AdminTariffsUpdateByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminTariffsList200ResponseItemsInner> {
            return localVarFp.adminTariffsUpdateById(id, adminTariffsUpdateByIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTripsList(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<AdminTripsList200Response> {
            return localVarFp.adminTripsList(limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint para scraping por Prometheus. Requiere header x-metrics-token si METRICS_TOKEN está definido o si METRICS_PUBLIC=false.
         * @summary Prometheus metrics (public)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsPublic(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.metricsPublic(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 */
export class AdminApi extends BaseAPI {
    /**
     * Estado de PostGIS y parÃ¡metros de matching (env) + contadores de uso.
     * @summary Diagnostics matching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminDiagnosticsMatching(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDiagnosticsMatching(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exposición de métricas en formato Prometheus. Protegido por rol ADMIN.
     * @summary Prometheus metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminMetrics(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminMetrics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crea una regla y opcionalmente desactiva reglas activas previas de la misma ciudad.
     * @summary Crear TariffRule
     * @param {AdminTariffsCreateRequest} adminTariffsCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminTariffsCreate(adminTariffsCreateRequest: AdminTariffsCreateRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminTariffsCreate(adminTariffsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lista reglas por ciudad.
     * @summary Listar TariffRule
     * @param {string} [city] 
     * @param {boolean} [active] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminTariffsList(city?: string, active?: boolean, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminTariffsList(city, active, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Actualiza campos de una regla por id.
     * @summary Actualizar TariffRule
     * @param {string} id 
     * @param {AdminTariffsUpdateByIdRequest} [adminTariffsUpdateByIdRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminTariffsUpdateById(id: string, adminTariffsUpdateByIdRequest?: AdminTariffsUpdateByIdRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminTariffsUpdateById(id, adminTariffsUpdateByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminTripsList(limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminTripsList(limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint para scraping por Prometheus. Requiere header x-metrics-token si METRICS_TOKEN está definido o si METRICS_PUBLIC=false.
     * @summary Prometheus metrics (public)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public metricsPublic(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).metricsPublic(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuthLoginRequest} authLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin: async (authLoginRequest: AuthLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authLoginRequest' is not null or undefined
            assertParamExists('authLogin', 'authLoginRequest', authLoginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthRegisterRequest} authRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegister: async (authRegisterRequest: AuthRegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRegisterRequest' is not null or undefined
            assertParamExists('authRegister', 'authRegisterRequest', authRegisterRequest)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRegisterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuthLoginRequest} authLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogin(authLoginRequest: AuthLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRegister201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogin(authLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthMe200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthRegisterRequest} authRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegister(authRegisterRequest: AuthRegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRegister201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegister(authRegisterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthLoginRequest} authLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin(authLoginRequest: AuthLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthRegister201Response> {
            return localVarFp.authLogin(authLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMe(options?: RawAxiosRequestConfig): AxiosPromise<AuthMe200Response> {
            return localVarFp.authMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthRegisterRequest} authRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegister(authRegisterRequest: AuthRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthRegister201Response> {
            return localVarFp.authRegister(authRegisterRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {AuthLoginRequest} authLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authLogin(authLoginRequest: AuthLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogin(authLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authMe(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthRegisterRequest} authRegisterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authRegister(authRegisterRequest: AuthRegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRegister(authRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthz: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/healthz`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthz(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthz(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.healthz']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthz(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.healthz(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthz(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthz(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DriversApi - axios parameter creator
 */
export const DriversApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
         * @summary Actualizar estado del driver
         * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        driverUpdateLocation: async (driverUpdateStatusRequest?: DriverUpdateStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/drivers/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driverUpdateStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
         * @summary Actualizar estado del driver
         * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        driverUpdateStatus: async (driverUpdateStatusRequest?: DriverUpdateStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/drivers/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driverUpdateStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DriversApi - functional programming interface
 */
export const DriversApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DriversApiAxiosParamCreator(configuration)
    return {
        /**
         * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
         * @summary Actualizar estado del driver
         * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async driverUpdateLocation(driverUpdateStatusRequest?: DriverUpdateStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverUpdateStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.driverUpdateLocation(driverUpdateStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DriversApi.driverUpdateLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
         * @summary Actualizar estado del driver
         * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async driverUpdateStatus(driverUpdateStatusRequest?: DriverUpdateStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverUpdateStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.driverUpdateStatus(driverUpdateStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DriversApi.driverUpdateStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DriversApi - factory interface
 */
export const DriversApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DriversApiFp(configuration)
    return {
        /**
         * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
         * @summary Actualizar estado del driver
         * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        driverUpdateLocation(driverUpdateStatusRequest?: DriverUpdateStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<DriverUpdateStatus200Response> {
            return localVarFp.driverUpdateLocation(driverUpdateStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
         * @summary Actualizar estado del driver
         * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        driverUpdateStatus(driverUpdateStatusRequest?: DriverUpdateStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<DriverUpdateStatus200Response> {
            return localVarFp.driverUpdateStatus(driverUpdateStatusRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DriversApi - object-oriented interface
 */
export class DriversApi extends BaseAPI {
    /**
     * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
     * @summary Actualizar estado del driver
     * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public driverUpdateLocation(driverUpdateStatusRequest?: DriverUpdateStatusRequest, options?: RawAxiosRequestConfig) {
        return DriversApiFp(this.configuration).driverUpdateLocation(driverUpdateStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
     * @summary Actualizar estado del driver
     * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public driverUpdateStatus(driverUpdateStatusRequest?: DriverUpdateStatusRequest, options?: RawAxiosRequestConfig) {
        return DriversApiFp(this.configuration).driverUpdateStatus(driverUpdateStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentsApi - axios parameter creator
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lista auditorias de reembolso/cancelaciÃ³n con filtros y CSV. Si format=csv, devuelve text/csv.
         * @summary Listar refunds (ADMIN)
         * @param {string} [userId] 
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {AdminRefundsListFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRefundsList: async (userId?: string, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: AdminRefundsListFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Captura un PaymentIntent autorizado de Stripe para el trip.
         * @summary Capturar pago autorizado (ADMIN)
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCaptureByTrip: async (tripId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tripId' is not null or undefined
            assertParamExists('paymentsCaptureByTrip', 'tripId', tripId)
            const localVarPath = `/payments/{tripId}/capture`
                .replace(`{${"tripId"}}`, encodeURIComponent(String(tripId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rider crea un SetupIntent para guardar una tarjeta. Devuelve client_secret.
         * @summary Crear SetupIntent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCreateSetupIntent: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payments/setup-intent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Devuelve el registro de Payment asociado a un Trip. Requiere JWT y ser dueÃ±o del viaje o ADMIN.
         * @summary Obtener pago por tripId
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsGetByTrip: async (tripId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tripId' is not null or undefined
            assertParamExists('paymentsGetByTrip', 'tripId', tripId)
            const localVarPath = `/payments/{tripId}`
                .replace(`{${"tripId"}}`, encodeURIComponent(String(tripId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lista pagos con filtros opcionales y paginacion. Si format=csv, devuelve text/csv.
         * @summary Listar pagos (ADMIN)
         * @param {string} [userId] 
         * @param {PaymentsListStatusEnum} [status] 
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {PaymentsListFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsList: async (userId?: string, status?: PaymentsListStatusEnum, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: PaymentsListFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recibo simple del pago asociado al viaje. type=TRIP o CANCELLATION_FEE.
         * @summary Obtener recibo
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsReceiptByTrip: async (tripId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tripId' is not null or undefined
            assertParamExists('paymentsReceiptByTrip', 'tripId', tripId)
            const localVarPath = `/payments/{tripId}/receipt`
                .replace(`{${"tripId"}}`, encodeURIComponent(String(tripId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reembolsa un Payment capturado (Stripe) o cancela autorizacion. Para otros metodos, marca REFUNDED y registra auditoria.
         * @summary Refund/cancel (ADMIN)
         * @param {string} tripId 
         * @param {PaymentsRefundByTripRequest} [paymentsRefundByTripRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsRefundByTrip: async (tripId: string, paymentsRefundByTripRequest?: PaymentsRefundByTripRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tripId' is not null or undefined
            assertParamExists('paymentsRefundByTrip', 'tripId', tripId)
            const localVarPath = `/payments/{tripId}/refund`
                .replace(`{${"tripId"}}`, encodeURIComponent(String(tripId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentsRefundByTripRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lista auditorias de reembolso/cancelaciÃ³n del pago de un trip. Requiere JWT y ser dueÃ±o del viaje o ADMIN.
         * @summary Refunds por tripId
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsRefundsByTrip: async (tripId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tripId' is not null or undefined
            assertParamExists('paymentsRefundsByTrip', 'tripId', tripId)
            const localVarPath = `/payments/{tripId}/refunds`
                .replace(`{${"tripId"}}`, encodeURIComponent(String(tripId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Guarda el paymentMethod como predeterminado en Stripe y DB.
         * @summary Definir PM por defecto
         * @param {PaymentsSetDefaultMethodRequest} paymentsSetDefaultMethodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsSetDefaultMethod: async (paymentsSetDefaultMethodRequest: PaymentsSetDefaultMethodRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentsSetDefaultMethodRequest' is not null or undefined
            assertParamExists('paymentsSetDefaultMethod', 'paymentsSetDefaultMethodRequest', paymentsSetDefaultMethodRequest)
            const localVarPath = `/payments/set-default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentsSetDefaultMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stripe webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksStripe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks/stripe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Lista auditorias de reembolso/cancelaciÃ³n con filtros y CSV. Si format=csv, devuelve text/csv.
         * @summary Listar refunds (ADMIN)
         * @param {string} [userId] 
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {AdminRefundsListFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminRefundsList(userId?: string, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: AdminRefundsListFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminRefundsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminRefundsList(userId, city, from, to, limit, cursor, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.adminRefundsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Captura un PaymentIntent autorizado de Stripe para el trip.
         * @summary Capturar pago autorizado (ADMIN)
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsCaptureByTrip(tripId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverUpdateStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsCaptureByTrip(tripId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsCaptureByTrip']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rider crea un SetupIntent para guardar una tarjeta. Devuelve client_secret.
         * @summary Crear SetupIntent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsCreateSetupIntent(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsCreateSetupIntent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsCreateSetupIntent(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsCreateSetupIntent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Devuelve el registro de Payment asociado a un Trip. Requiere JWT y ser dueÃ±o del viaje o ADMIN.
         * @summary Obtener pago por tripId
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsGetByTrip(tripId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsList200ResponseItemsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsGetByTrip(tripId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsGetByTrip']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lista pagos con filtros opcionales y paginacion. Si format=csv, devuelve text/csv.
         * @summary Listar pagos (ADMIN)
         * @param {string} [userId] 
         * @param {PaymentsListStatusEnum} [status] 
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {PaymentsListFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsList(userId?: string, status?: PaymentsListStatusEnum, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: PaymentsListFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsList(userId, status, city, from, to, limit, cursor, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recibo simple del pago asociado al viaje. type=TRIP o CANCELLATION_FEE.
         * @summary Obtener recibo
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsReceiptByTrip(tripId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsReceiptByTrip200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsReceiptByTrip(tripId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsReceiptByTrip']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reembolsa un Payment capturado (Stripe) o cancela autorizacion. Para otros metodos, marca REFUNDED y registra auditoria.
         * @summary Refund/cancel (ADMIN)
         * @param {string} tripId 
         * @param {PaymentsRefundByTripRequest} [paymentsRefundByTripRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsRefundByTrip(tripId: string, paymentsRefundByTripRequest?: PaymentsRefundByTripRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverUpdateStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsRefundByTrip(tripId, paymentsRefundByTripRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsRefundByTrip']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lista auditorias de reembolso/cancelaciÃ³n del pago de un trip. Requiere JWT y ser dueÃ±o del viaje o ADMIN.
         * @summary Refunds por tripId
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsRefundsByTrip(tripId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsRefundsByTrip200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsRefundsByTrip(tripId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsRefundsByTrip']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Guarda el paymentMethod como predeterminado en Stripe y DB.
         * @summary Definir PM por defecto
         * @param {PaymentsSetDefaultMethodRequest} paymentsSetDefaultMethodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsSetDefaultMethod(paymentsSetDefaultMethodRequest: PaymentsSetDefaultMethodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverUpdateStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsSetDefaultMethod(paymentsSetDefaultMethodRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsSetDefaultMethod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stripe webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksStripe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksStripe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.webhooksStripe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentsApi - factory interface
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * Lista auditorias de reembolso/cancelaciÃ³n con filtros y CSV. Si format=csv, devuelve text/csv.
         * @summary Listar refunds (ADMIN)
         * @param {string} [userId] 
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {AdminRefundsListFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRefundsList(userId?: string, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: AdminRefundsListFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<AdminRefundsList200Response> {
            return localVarFp.adminRefundsList(userId, city, from, to, limit, cursor, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Captura un PaymentIntent autorizado de Stripe para el trip.
         * @summary Capturar pago autorizado (ADMIN)
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCaptureByTrip(tripId: string, options?: RawAxiosRequestConfig): AxiosPromise<DriverUpdateStatus200Response> {
            return localVarFp.paymentsCaptureByTrip(tripId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rider crea un SetupIntent para guardar una tarjeta. Devuelve client_secret.
         * @summary Crear SetupIntent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCreateSetupIntent(options?: RawAxiosRequestConfig): AxiosPromise<PaymentsCreateSetupIntent200Response> {
            return localVarFp.paymentsCreateSetupIntent(options).then((request) => request(axios, basePath));
        },
        /**
         * Devuelve el registro de Payment asociado a un Trip. Requiere JWT y ser dueÃ±o del viaje o ADMIN.
         * @summary Obtener pago por tripId
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsGetByTrip(tripId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsList200ResponseItemsInner> {
            return localVarFp.paymentsGetByTrip(tripId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lista pagos con filtros opcionales y paginacion. Si format=csv, devuelve text/csv.
         * @summary Listar pagos (ADMIN)
         * @param {string} [userId] 
         * @param {PaymentsListStatusEnum} [status] 
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {PaymentsListFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsList(userId?: string, status?: PaymentsListStatusEnum, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: PaymentsListFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsList200Response> {
            return localVarFp.paymentsList(userId, status, city, from, to, limit, cursor, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Recibo simple del pago asociado al viaje. type=TRIP o CANCELLATION_FEE.
         * @summary Obtener recibo
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsReceiptByTrip(tripId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsReceiptByTrip200Response> {
            return localVarFp.paymentsReceiptByTrip(tripId, options).then((request) => request(axios, basePath));
        },
        /**
         * Reembolsa un Payment capturado (Stripe) o cancela autorizacion. Para otros metodos, marca REFUNDED y registra auditoria.
         * @summary Refund/cancel (ADMIN)
         * @param {string} tripId 
         * @param {PaymentsRefundByTripRequest} [paymentsRefundByTripRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsRefundByTrip(tripId: string, paymentsRefundByTripRequest?: PaymentsRefundByTripRequest, options?: RawAxiosRequestConfig): AxiosPromise<DriverUpdateStatus200Response> {
            return localVarFp.paymentsRefundByTrip(tripId, paymentsRefundByTripRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Lista auditorias de reembolso/cancelaciÃ³n del pago de un trip. Requiere JWT y ser dueÃ±o del viaje o ADMIN.
         * @summary Refunds por tripId
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsRefundsByTrip(tripId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsRefundsByTrip200Response> {
            return localVarFp.paymentsRefundsByTrip(tripId, options).then((request) => request(axios, basePath));
        },
        /**
         * Guarda el paymentMethod como predeterminado en Stripe y DB.
         * @summary Definir PM por defecto
         * @param {PaymentsSetDefaultMethodRequest} paymentsSetDefaultMethodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsSetDefaultMethod(paymentsSetDefaultMethodRequest: PaymentsSetDefaultMethodRequest, options?: RawAxiosRequestConfig): AxiosPromise<DriverUpdateStatus200Response> {
            return localVarFp.paymentsSetDefaultMethod(paymentsSetDefaultMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stripe webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksStripe(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.webhooksStripe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 */
export class PaymentsApi extends BaseAPI {
    /**
     * Lista auditorias de reembolso/cancelaciÃ³n con filtros y CSV. Si format=csv, devuelve text/csv.
     * @summary Listar refunds (ADMIN)
     * @param {string} [userId] 
     * @param {string} [city] 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {AdminRefundsListFormatEnum} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminRefundsList(userId?: string, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: AdminRefundsListFormatEnum, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).adminRefundsList(userId, city, from, to, limit, cursor, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Captura un PaymentIntent autorizado de Stripe para el trip.
     * @summary Capturar pago autorizado (ADMIN)
     * @param {string} tripId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsCaptureByTrip(tripId: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsCaptureByTrip(tripId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rider crea un SetupIntent para guardar una tarjeta. Devuelve client_secret.
     * @summary Crear SetupIntent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsCreateSetupIntent(options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsCreateSetupIntent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Devuelve el registro de Payment asociado a un Trip. Requiere JWT y ser dueÃ±o del viaje o ADMIN.
     * @summary Obtener pago por tripId
     * @param {string} tripId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsGetByTrip(tripId: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsGetByTrip(tripId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lista pagos con filtros opcionales y paginacion. Si format=csv, devuelve text/csv.
     * @summary Listar pagos (ADMIN)
     * @param {string} [userId] 
     * @param {PaymentsListStatusEnum} [status] 
     * @param {string} [city] 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {PaymentsListFormatEnum} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsList(userId?: string, status?: PaymentsListStatusEnum, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: PaymentsListFormatEnum, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsList(userId, status, city, from, to, limit, cursor, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recibo simple del pago asociado al viaje. type=TRIP o CANCELLATION_FEE.
     * @summary Obtener recibo
     * @param {string} tripId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsReceiptByTrip(tripId: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsReceiptByTrip(tripId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reembolsa un Payment capturado (Stripe) o cancela autorizacion. Para otros metodos, marca REFUNDED y registra auditoria.
     * @summary Refund/cancel (ADMIN)
     * @param {string} tripId 
     * @param {PaymentsRefundByTripRequest} [paymentsRefundByTripRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsRefundByTrip(tripId: string, paymentsRefundByTripRequest?: PaymentsRefundByTripRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsRefundByTrip(tripId, paymentsRefundByTripRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lista auditorias de reembolso/cancelaciÃ³n del pago de un trip. Requiere JWT y ser dueÃ±o del viaje o ADMIN.
     * @summary Refunds por tripId
     * @param {string} tripId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsRefundsByTrip(tripId: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsRefundsByTrip(tripId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Guarda el paymentMethod como predeterminado en Stripe y DB.
     * @summary Definir PM por defecto
     * @param {PaymentsSetDefaultMethodRequest} paymentsSetDefaultMethodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsSetDefaultMethod(paymentsSetDefaultMethodRequest: PaymentsSetDefaultMethodRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsSetDefaultMethod(paymentsSetDefaultMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stripe webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksStripe(options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).webhooksStripe(options).then((request) => request(this.axios, this.basePath));
    }
}

export const AdminRefundsListFormatEnum = {
    Json: 'json',
    Csv: 'csv'
} as const;
export type AdminRefundsListFormatEnum = typeof AdminRefundsListFormatEnum[keyof typeof AdminRefundsListFormatEnum];
export const PaymentsListStatusEnum = {
    Pending: 'PENDING',
    Authorized: 'AUTHORIZED',
    Paid: 'PAID',
    Failed: 'FAILED',
    Refunded: 'REFUNDED'
} as const;
export type PaymentsListStatusEnum = typeof PaymentsListStatusEnum[keyof typeof PaymentsListStatusEnum];
export const PaymentsListFormatEnum = {
    Json: 'json',
    Csv: 'csv'
} as const;
export type PaymentsListFormatEnum = typeof PaymentsListFormatEnum[keyof typeof PaymentsListFormatEnum];


/**
 * TripsApi - axios parameter creator
 */
export const TripsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsAccept: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tripsAccept', 'id', id)
            const localVarPath = `/trips/{id}/accept`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsArrived: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tripsArrived', 'id', id)
            const localVarPath = `/trips/{id}/arrived`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {TripsCancelRequest} [tripsCancelRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsCancel: async (id: string, tripsCancelRequest?: TripsCancelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tripsCancel', 'id', id)
            const localVarPath = `/trips/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tripsCancelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsComplete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tripsComplete', 'id', id)
            const localVarPath = `/trips/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crea un viaje y asigna el conductor disponible más cercano.
         * @summary Solicitar viaje
         * @param {TripsRequestRequest} tripsRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsRequest: async (tripsRequestRequest: TripsRequestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tripsRequestRequest' is not null or undefined
            assertParamExists('tripsRequest', 'tripsRequestRequest', tripsRequestRequest)
            const localVarPath = `/trips/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tripsRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stream de eventos del viaje en tiempo real para Rider/Driver via Server-Sent Events. Envía eventos como INIT/ASSIGNED/ACCEPTED/ARRIVED/STARTED/COMPLETED/CANCELED.
         * @summary Trip live updates (SSE)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsSseById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tripsSseById', 'id', id)
            const localVarPath = `/trips/{id}/sse`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsStart: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tripsStart', 'id', id)
            const localVarPath = `/trips/{id}/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TripsApi - functional programming interface
 */
export const TripsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TripsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsAccept(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripsRequest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsAccept(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TripsApi.tripsAccept']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsArrived(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripsRequest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsArrived(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TripsApi.tripsArrived']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {TripsCancelRequest} [tripsCancelRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsCancel(id: string, tripsCancelRequest?: TripsCancelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripsRequest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsCancel(id, tripsCancelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TripsApi.tripsCancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsComplete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripsRequest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsComplete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TripsApi.tripsComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Crea un viaje y asigna el conductor disponible más cercano.
         * @summary Solicitar viaje
         * @param {TripsRequestRequest} tripsRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsRequest(tripsRequestRequest: TripsRequestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripsRequest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsRequest(tripsRequestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TripsApi.tripsRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stream de eventos del viaje en tiempo real para Rider/Driver via Server-Sent Events. Envía eventos como INIT/ASSIGNED/ACCEPTED/ARRIVED/STARTED/COMPLETED/CANCELED.
         * @summary Trip live updates (SSE)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsSseById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsSseById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TripsApi.tripsSseById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsStart(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripsRequest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsStart(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TripsApi.tripsStart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TripsApi - factory interface
 */
export const TripsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TripsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsAccept(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TripsRequest200Response> {
            return localVarFp.tripsAccept(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsArrived(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TripsRequest200Response> {
            return localVarFp.tripsArrived(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {TripsCancelRequest} [tripsCancelRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsCancel(id: string, tripsCancelRequest?: TripsCancelRequest, options?: RawAxiosRequestConfig): AxiosPromise<TripsRequest200Response> {
            return localVarFp.tripsCancel(id, tripsCancelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsComplete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TripsRequest200Response> {
            return localVarFp.tripsComplete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Crea un viaje y asigna el conductor disponible más cercano.
         * @summary Solicitar viaje
         * @param {TripsRequestRequest} tripsRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsRequest(tripsRequestRequest: TripsRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<TripsRequest200Response> {
            return localVarFp.tripsRequest(tripsRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Stream de eventos del viaje en tiempo real para Rider/Driver via Server-Sent Events. Envía eventos como INIT/ASSIGNED/ACCEPTED/ARRIVED/STARTED/COMPLETED/CANCELED.
         * @summary Trip live updates (SSE)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsSseById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.tripsSseById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsStart(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TripsRequest200Response> {
            return localVarFp.tripsStart(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TripsApi - object-oriented interface
 */
export class TripsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tripsAccept(id: string, options?: RawAxiosRequestConfig) {
        return TripsApiFp(this.configuration).tripsAccept(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tripsArrived(id: string, options?: RawAxiosRequestConfig) {
        return TripsApiFp(this.configuration).tripsArrived(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {TripsCancelRequest} [tripsCancelRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tripsCancel(id: string, tripsCancelRequest?: TripsCancelRequest, options?: RawAxiosRequestConfig) {
        return TripsApiFp(this.configuration).tripsCancel(id, tripsCancelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tripsComplete(id: string, options?: RawAxiosRequestConfig) {
        return TripsApiFp(this.configuration).tripsComplete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crea un viaje y asigna el conductor disponible más cercano.
     * @summary Solicitar viaje
     * @param {TripsRequestRequest} tripsRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tripsRequest(tripsRequestRequest: TripsRequestRequest, options?: RawAxiosRequestConfig) {
        return TripsApiFp(this.configuration).tripsRequest(tripsRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stream de eventos del viaje en tiempo real para Rider/Driver via Server-Sent Events. Envía eventos como INIT/ASSIGNED/ACCEPTED/ARRIVED/STARTED/COMPLETED/CANCELED.
     * @summary Trip live updates (SSE)
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tripsSseById(id: string, options?: RawAxiosRequestConfig) {
        return TripsApiFp(this.configuration).tripsSseById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tripsStart(id: string, options?: RawAxiosRequestConfig) {
        return TripsApiFp(this.configuration).tripsStart(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Borra el FCM token asociado al usuario (logout de push notifications).
         * @summary Eliminar FCM token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeletePushToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/push-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registra o actualiza el FCM token del usuario logueado.
         * @summary Registrar FCM token
         * @param {UsersRegisterPushTokenRequest} usersRegisterPushTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRegisterPushToken: async (usersRegisterPushTokenRequest: UsersRegisterPushTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersRegisterPushTokenRequest' is not null or undefined
            assertParamExists('usersRegisterPushToken', 'usersRegisterPushTokenRequest', usersRegisterPushTokenRequest)
            const localVarPath = `/users/me/push-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersRegisterPushTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Borra el FCM token asociado al usuario (logout de push notifications).
         * @summary Eliminar FCM token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDeletePushToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersRegisterPushToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDeletePushToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersDeletePushToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Registra o actualiza el FCM token del usuario logueado.
         * @summary Registrar FCM token
         * @param {UsersRegisterPushTokenRequest} usersRegisterPushTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRegisterPushToken(usersRegisterPushTokenRequest: UsersRegisterPushTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersRegisterPushToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersRegisterPushToken(usersRegisterPushTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersRegisterPushToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Borra el FCM token asociado al usuario (logout de push notifications).
         * @summary Eliminar FCM token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeletePushToken(options?: RawAxiosRequestConfig): AxiosPromise<UsersRegisterPushToken200Response> {
            return localVarFp.usersDeletePushToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Registra o actualiza el FCM token del usuario logueado.
         * @summary Registrar FCM token
         * @param {UsersRegisterPushTokenRequest} usersRegisterPushTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRegisterPushToken(usersRegisterPushTokenRequest: UsersRegisterPushTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<UsersRegisterPushToken200Response> {
            return localVarFp.usersRegisterPushToken(usersRegisterPushTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * Borra el FCM token asociado al usuario (logout de push notifications).
     * @summary Eliminar FCM token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersDeletePushToken(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDeletePushToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registra o actualiza el FCM token del usuario logueado.
     * @summary Registrar FCM token
     * @param {UsersRegisterPushTokenRequest} usersRegisterPushTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersRegisterPushToken(usersRegisterPushTokenRequest: UsersRegisterPushTokenRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersRegisterPushToken(usersRegisterPushTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



