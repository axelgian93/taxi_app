/* tslint:disable */
/* eslint-disable */
/**
 * Taxi API
 * API de Taxi
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AdminDiagnosticsMatching200Response {
    'postgisAvailable'?: boolean;
    'env'?: AdminDiagnosticsMatching200ResponseEnv;
    'counters'?: { [key: string]: number; };
}
export interface AdminDiagnosticsMatching200ResponseEnv {
    'MATCH_RADIUS_M'?: number;
    'LOCATION_MAX_AGE_MIN'?: number;
}
export interface AdminDiagnosticsMatchingTest200Response {
    'postgisAvailable'?: boolean;
    'modeUsed'?: AdminDiagnosticsMatchingTest200ResponseModeUsedEnum;
    'driverId'?: string | null;
    'meters'?: number | null;
    'candidatesChecked'?: number | null;
}

export const AdminDiagnosticsMatchingTest200ResponseModeUsedEnum = {
    Postgis: 'POSTGIS',
    Haversine: 'HAVERSINE',
    Idle: 'IDLE'
} as const;

export type AdminDiagnosticsMatchingTest200ResponseModeUsedEnum = typeof AdminDiagnosticsMatchingTest200ResponseModeUsedEnum[keyof typeof AdminDiagnosticsMatchingTest200ResponseModeUsedEnum];

export interface AdminDiagnosticsMatchingTestRequest {
    'pickupLat': number;
    'pickupLng': number;
    'radiusM'?: number;
    'maxAgeMin'?: number;
}
export interface AdminPaymentsReport200Response {
    'items'?: Array<{ [key: string]: any; }>;
    'totals'?: AdminPaymentsReport200ResponseTotals;
}
export interface AdminPaymentsReport200ResponseTotals {
    'count'?: number;
    'amountUsd'?: number;
}
export interface AdminPaymentsSummaryStatus200Response {
    'items'?: Array<AdminPaymentsSummaryStatus200ResponseItemsInner>;
    'totals'?: AdminPaymentsReport200ResponseTotals;
}
export interface AdminPaymentsSummaryStatus200ResponseItemsInner {
    'status'?: string;
    'count'?: number;
    'amountUsd'?: number;
}
export interface AdminPaymentsTopDrivers200Response {
    'items'?: Array<AdminPaymentsTopDrivers200ResponseItemsInner>;
    'totals'?: AdminPaymentsTopDrivers200ResponseTotals;
}
export interface AdminPaymentsTopDrivers200ResponseItemsInner {
    'driverId'?: string;
    'email'?: string;
    'fullName'?: string;
    'trips'?: number;
    'amountUsd'?: number;
}
export interface AdminPaymentsTopDrivers200ResponseTotals {
    'trips'?: number;
    'amountUsd'?: number;
}
export interface AdminPaymentsTopRiders200Response {
    'items'?: Array<AdminPaymentsTopRiders200ResponseItemsInner>;
    'totals'?: AdminPaymentsTopDrivers200ResponseTotals;
}
export interface AdminPaymentsTopRiders200ResponseItemsInner {
    'riderId'?: string;
    'email'?: string;
    'fullName'?: string;
    'trips'?: number;
    'amountUsd'?: number;
}
export interface AdminRefundsList200Response {
    'items'?: Array<PaymentsRefundsByTrip200ResponseItemsInner>;
    'nextCursor'?: string | null;
}
export interface AdminTariffsCreateRequest {
    'city': string;
    'active'?: boolean;
    'baseFareUsd': number;
    'perKmUsd': number;
    'perMinUsd': number;
    'minFareUsd'?: number;
    'nightMultiplier'?: number;
    'weekendMultiplier'?: number;
    'surgeMultiplier'?: number;
    'nightStartHour'?: number | null;
    'nightEndHour'?: number | null;
    'cancellationGraceSec'?: number | null;
    'cancellationFeeAcceptedUsd'?: number;
    'cancellationFeeArrivedUsd'?: number;
    'notes'?: string | null;
    /**
     * Si true, desactiva reglas activas previas de la misma ciudad
     */
    'deactivateOld'?: boolean;
}
export interface AdminTariffsList200Response {
    'items'?: Array<AdminTariffsList200ResponseItemsInner>;
}
export interface AdminTariffsList200ResponseItemsInner {
    'id'?: string;
    'city'?: string;
    'active'?: boolean;
    'baseFareUsd'?: number;
    'perKmUsd'?: number;
    'perMinUsd'?: number;
    'minFareUsd'?: number;
    'nightMultiplier'?: number;
    'weekendMultiplier'?: number;
    'surgeMultiplier'?: number;
    'nightStartHour'?: number | null;
    'nightEndHour'?: number | null;
    'cancellationGraceSec'?: number | null;
    'cancellationFeeAcceptedUsd'?: number;
    'cancellationFeeArrivedUsd'?: number;
    'validFrom'?: string | null;
    'validTo'?: string | null;
    'notes'?: string | null;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface AdminTariffsUpdateByIdRequest {
    'city'?: string;
    'active'?: boolean;
    'baseFareUsd'?: number;
    'perKmUsd'?: number;
    'perMinUsd'?: number;
    'minFareUsd'?: number;
    'nightMultiplier'?: number;
    'weekendMultiplier'?: number;
    'surgeMultiplier'?: number;
    'nightStartHour'?: number | null;
    'nightEndHour'?: number | null;
    'cancellationGraceSec'?: number | null;
    'cancellationFeeAcceptedUsd'?: number;
    'cancellationFeeArrivedUsd'?: number;
    'notes'?: string | null;
    /**
     * Si true, desactiva reglas activas previas de la misma ciudad
     */
    'deactivateOld'?: boolean;
}
export interface AdminTripsList200Response {
    'items'?: Array<AdminTripsList200ResponseItemsInner>;
    'nextCursor'?: string | null;
}
export interface AdminTripsList200ResponseItemsInner {
    'id'?: string;
    'status'?: string;
    'riderId'?: string;
    'driverId'?: string;
    'requestedAt'?: string;
    'completedAt'?: string | null;
    'costUsd'?: number;
    'currency'?: string;
}
export interface AuthLoginRequest {
    'email': string;
    'password': string;
}
export interface AuthLogout200Response {
    'ok'?: boolean;
}
export interface AuthLogoutRequest {
    'refreshToken'?: string;
}
export interface AuthMe200Response {
    'user'?: AuthMe200ResponseUser;
}
export interface AuthMe200ResponseUser {
    'id'?: string;
    'email'?: string;
    'role'?: AuthMe200ResponseUserRoleEnum;
    'firstName'?: string;
    'lastName'?: string;
}

export const AuthMe200ResponseUserRoleEnum = {
    Admin: 'ADMIN',
    Driver: 'DRIVER',
    Rider: 'RIDER'
} as const;

export type AuthMe200ResponseUserRoleEnum = typeof AuthMe200ResponseUserRoleEnum[keyof typeof AuthMe200ResponseUserRoleEnum];

export interface AuthRefresh200Response {
    'token'?: string;
    'refreshToken'?: string;
}
export interface AuthRefreshRequest {
    'refreshToken': string;
}
export interface AuthRegister201Response {
    'token'?: string;
    'refreshToken'?: string;
    'user'?: AuthRegister201ResponseUser;
}
export interface AuthRegister201ResponseUser {
    'id'?: string;
    'email'?: string;
    'role'?: AuthRegister201ResponseUserRoleEnum;
}

export const AuthRegister201ResponseUserRoleEnum = {
    Admin: 'ADMIN',
    Driver: 'DRIVER',
    Rider: 'RIDER'
} as const;

export type AuthRegister201ResponseUserRoleEnum = typeof AuthRegister201ResponseUserRoleEnum[keyof typeof AuthRegister201ResponseUserRoleEnum];

export interface AuthRegister400Response {
    'error'?: string;
}
export interface AuthRegisterRequest {
    'email': string;
    'password': string;
    'firstName': string;
    'lastName': string;
    'role': AuthRegisterRequestRoleEnum;
}

export const AuthRegisterRequestRoleEnum = {
    Admin: 'ADMIN',
    Driver: 'DRIVER',
    Rider: 'RIDER'
} as const;

export type AuthRegisterRequestRoleEnum = typeof AuthRegisterRequestRoleEnum[keyof typeof AuthRegisterRequestRoleEnum];

export interface DriverMyTripsActive200Response {
    'items'?: Array<DriverMyTripsActive200ResponseItemsInner>;
}
export interface DriverMyTripsActive200ResponseItemsInner {
    'id'?: string;
    'status'?: DriverMyTripsActive200ResponseItemsInnerStatusEnum;
    'pickupLat'?: number;
    'pickupLng'?: number;
    'dropoffLat'?: number;
    'dropoffLng'?: number;
    'requestedAt'?: string;
    'preferredMethod'?: DriverMyTripsActive200ResponseItemsInnerPreferredMethodEnum | null;
}

export const DriverMyTripsActive200ResponseItemsInnerStatusEnum = {
    Accepted: 'ACCEPTED',
    Arrived: 'ARRIVED',
    Started: 'STARTED'
} as const;

export type DriverMyTripsActive200ResponseItemsInnerStatusEnum = typeof DriverMyTripsActive200ResponseItemsInnerStatusEnum[keyof typeof DriverMyTripsActive200ResponseItemsInnerStatusEnum];
export const DriverMyTripsActive200ResponseItemsInnerPreferredMethodEnum = {
    Cash: 'CASH',
    Card: 'CARD'
} as const;

export type DriverMyTripsActive200ResponseItemsInnerPreferredMethodEnum = typeof DriverMyTripsActive200ResponseItemsInnerPreferredMethodEnum[keyof typeof DriverMyTripsActive200ResponseItemsInnerPreferredMethodEnum];

export interface DriverMyTripsActive403Response {
    'error'?: string;
}
export interface DriverMyTripsHistory200Response {
    'items'?: Array<DriverMyTripsHistory200ResponseItemsInner>;
    'nextCursor'?: string | null;
}
export interface DriverMyTripsHistory200ResponseItemsInner {
    'id'?: string;
    'status'?: DriverMyTripsHistory200ResponseItemsInnerStatusEnum;
    'pickupLat'?: number;
    'pickupLng'?: number;
    'dropoffLat'?: number;
    'dropoffLng'?: number;
    'requestedAt'?: string;
    'completedAt'?: string | null;
    'costUsd'?: number | null;
    'currency'?: string | null;
}

export const DriverMyTripsHistory200ResponseItemsInnerStatusEnum = {
    Completed: 'COMPLETED',
    Canceled: 'CANCELED'
} as const;

export type DriverMyTripsHistory200ResponseItemsInnerStatusEnum = typeof DriverMyTripsHistory200ResponseItemsInnerStatusEnum[keyof typeof DriverMyTripsHistory200ResponseItemsInnerStatusEnum];

export interface DriverUpdateStatus200Response {
    'ok'?: boolean;
}
export interface DriverUpdateStatus401Response {
    'error'?: string;
}
export interface DriverUpdateStatusRequest {
    'lat'?: number;
    'lng'?: number;
    'status'?: DriverUpdateStatusRequestStatusEnum;
}

export const DriverUpdateStatusRequestStatusEnum = {
    Idle: 'IDLE',
    Assigned: 'ASSIGNED',
    Arrived: 'ARRIVED',
    OnTrip: 'ON_TRIP',
    Offline: 'OFFLINE'
} as const;

export type DriverUpdateStatusRequestStatusEnum = typeof DriverUpdateStatusRequestStatusEnum[keyof typeof DriverUpdateStatusRequestStatusEnum];

export interface PaymentsCaptureByTrip400Response {
    'error'?: string;
}
export interface PaymentsCaptureByTrip404Response {
    'error'?: string;
}
export interface PaymentsCreateSetupIntent200Response {
    'clientSecret'?: string;
}
export interface PaymentsList200Response {
    'items'?: Array<PaymentsList200ResponseItemsInner>;
    'nextCursor'?: string | null;
}
export interface PaymentsList200ResponseItemsInner {
    'id'?: string;
    'tripId'?: string;
    'amountUsd'?: number;
    'status'?: PaymentsList200ResponseItemsInnerStatusEnum;
    'method'?: string;
    'provider'?: string | null;
    'externalId'?: string | null;
    'createdAt'?: string;
    'updatedAt'?: string;
    'isAuthorized'?: boolean;
    'isPaid'?: boolean;
    'isFailed'?: boolean;
    'providerDisplay'?: string;
    'capturable'?: boolean;
}

export const PaymentsList200ResponseItemsInnerStatusEnum = {
    Pending: 'PENDING',
    Authorized: 'AUTHORIZED',
    Paid: 'PAID',
    Failed: 'FAILED',
    Refunded: 'REFUNDED'
} as const;

export type PaymentsList200ResponseItemsInnerStatusEnum = typeof PaymentsList200ResponseItemsInnerStatusEnum[keyof typeof PaymentsList200ResponseItemsInnerStatusEnum];

export interface PaymentsReceiptByTrip200Response {
    'tripId'?: string;
    'amountUsd'?: number;
    'currency'?: string;
    'method'?: string;
    'status'?: string;
    'provider'?: string | null;
    'type'?: PaymentsReceiptByTrip200ResponseTypeEnum;
    'paidAt'?: string | null;
}

export const PaymentsReceiptByTrip200ResponseTypeEnum = {
    Trip: 'TRIP',
    CancellationFee: 'CANCELLATION_FEE'
} as const;

export type PaymentsReceiptByTrip200ResponseTypeEnum = typeof PaymentsReceiptByTrip200ResponseTypeEnum[keyof typeof PaymentsReceiptByTrip200ResponseTypeEnum];

export interface PaymentsRefundByTripRequest {
    'amountUsd'?: number;
    'reason'?: string;
}
export interface PaymentsRefundsByTrip200Response {
    'items'?: Array<PaymentsRefundsByTrip200ResponseItemsInner>;
}
export interface PaymentsRefundsByTrip200ResponseItemsInner {
    'id'?: string;
    'paymentId'?: string;
    'tripId'?: string;
    'amountUsd'?: number;
    'reason'?: string | null;
    'provider'?: string | null;
    'externalId'?: string | null;
    'createdAt'?: string;
}
export interface PaymentsRefundsByTrip404Response {
    'error'?: string;
}
export interface PaymentsSetDefaultMethodRequest {
    'paymentMethodId': string;
}
export interface RiderMyTrips200Response {
    'items'?: Array<RiderMyTrips200ResponseItemsInner>;
    'nextCursor'?: string | null;
}
export interface RiderMyTrips200ResponseItemsInner {
    'id'?: string;
    'status'?: RiderMyTrips200ResponseItemsInnerStatusEnum;
    'pickupLat'?: number;
    'pickupLng'?: number;
    'dropoffLat'?: number;
    'dropoffLng'?: number;
    'requestedAt'?: string;
    'completedAt'?: string | null;
    'costUsd'?: number | null;
    'currency'?: string | null;
    'preferredMethod'?: RiderMyTrips200ResponseItemsInnerPreferredMethodEnum | null;
}

export const RiderMyTrips200ResponseItemsInnerStatusEnum = {
    Requested: 'REQUESTED',
    Assigned: 'ASSIGNED',
    Accepted: 'ACCEPTED',
    Arrived: 'ARRIVED',
    Started: 'STARTED',
    Completed: 'COMPLETED',
    Canceled: 'CANCELED'
} as const;

export type RiderMyTrips200ResponseItemsInnerStatusEnum = typeof RiderMyTrips200ResponseItemsInnerStatusEnum[keyof typeof RiderMyTrips200ResponseItemsInnerStatusEnum];
export const RiderMyTrips200ResponseItemsInnerPreferredMethodEnum = {
    Cash: 'CASH',
    Card: 'CARD'
} as const;

export type RiderMyTrips200ResponseItemsInnerPreferredMethodEnum = typeof RiderMyTrips200ResponseItemsInnerPreferredMethodEnum[keyof typeof RiderMyTrips200ResponseItemsInnerPreferredMethodEnum];

export interface TripsAccept400Response {
    'error'?: string;
}
export interface TripsAccept404Response {
    'error'?: string;
}
export interface TripsAccept409Response {
    'error'?: string;
}
export interface TripsArrived200Response {
    'ok'?: boolean;
    'trip'?: TripsRequest200ResponseTrip;
}
export interface TripsArrived409Response {
    'error'?: string;
}
export interface TripsCancel200Response {
    'ok'?: boolean;
    'trip'?: TripsRequest200ResponseTrip;
}
export interface TripsCancel409Response {
    'error'?: string;
}
export interface TripsCancelRequest {
    'reason'?: string;
}
export interface TripsComplete200Response {
    'ok'?: boolean;
    'trip'?: TripsRequest200ResponseTrip;
}
export interface TripsComplete409Response {
    'error'?: string;
}
export interface TripsDriverLocation200Response {
    'tripId'?: string;
    'driverId'?: string | null;
    'lat'?: number | null;
    'lng'?: number | null;
    'locationUpdatedAt'?: string | null;
}
export interface TripsRequest200Response {
    'ok'?: boolean;
    'trip'?: TripsRequest200ResponseTrip;
}
export interface TripsRequest200ResponseTrip {
    'id'?: string;
    'status'?: string;
}
export interface TripsRequest400Response {
    'error'?: string;
}
export interface TripsRequestRequest {
    'city': string;
    'pickupLat': number;
    'pickupLng': number;
    'dropoffLat': number;
    'dropoffLng': number;
    'pickupAddress'?: string | null;
    'dropoffAddress'?: string | null;
    'distanceKm': number;
    'durationMin': number;
    'preferredMethod'?: TripsRequestRequestPreferredMethodEnum | null;
}

export const TripsRequestRequestPreferredMethodEnum = {
    Cash: 'CASH',
    Card: 'CARD'
} as const;

export type TripsRequestRequestPreferredMethodEnum = typeof TripsRequestRequestPreferredMethodEnum[keyof typeof TripsRequestRequestPreferredMethodEnum];

export interface TripsStart200Response {
    'ok'?: boolean;
    'trip'?: TripsRequest200ResponseTrip;
}
export interface TripsStart409Response {
    'error'?: string;
}
export interface TripsStartRequest {
    'method'?: TripsStartRequestMethodEnum;
}

export const TripsStartRequestMethodEnum = {
    Cash: 'CASH',
    Card: 'CARD'
} as const;

export type TripsStartRequestMethodEnum = typeof TripsStartRequestMethodEnum[keyof typeof TripsStartRequestMethodEnum];

export interface UsersRegisterPushTokenRequest {
    'fcmToken': string;
}

/**
 * AdminApi - axios parameter creator
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Estado de PostGIS y parÃ¡metros de matching (env) + contadores de uso.
         * @summary Diagnostics matching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDiagnosticsMatching: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/diagnostics/matching`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Intenta encontrar el driver más cercano usando PostGIS si está disponible; de lo contrario cae a Haversine y finalmente idle fallback. Incrementa contadores de métricas según el camino usado.
         * @summary Probar matching (PostGIS/Haversine/Idle)
         * @param {AdminDiagnosticsMatchingTestRequest} adminDiagnosticsMatchingTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDiagnosticsMatchingTest: async (adminDiagnosticsMatchingTestRequest: AdminDiagnosticsMatchingTestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminDiagnosticsMatchingTestRequest' is not null or undefined
            assertParamExists('adminDiagnosticsMatchingTest', 'adminDiagnosticsMatchingTestRequest', adminDiagnosticsMatchingTestRequest)
            const localVarPath = `/admin/diagnostics/matching/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminDiagnosticsMatchingTestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ExposiciÃ³n de mÃ©tricas en formato Prometheus. Protegido por rol ADMIN.
         * @summary Prometheus metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminMetrics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crea una regla y opcionalmente desactiva reglas activas previas de la misma ciudad.
         * @summary Crear TariffRule
         * @param {AdminTariffsCreateRequest} adminTariffsCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTariffsCreate: async (adminTariffsCreateRequest: AdminTariffsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminTariffsCreateRequest' is not null or undefined
            assertParamExists('adminTariffsCreate', 'adminTariffsCreateRequest', adminTariffsCreateRequest)
            const localVarPath = `/admin/tariffs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminTariffsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lista reglas por ciudad.
         * @summary Listar TariffRule
         * @param {string} [city] 
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTariffsList: async (city?: string, active?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/tariffs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Actualiza campos de una regla por id.
         * @summary Actualizar TariffRule
         * @param {string} id 
         * @param {AdminTariffsUpdateByIdRequest} [adminTariffsUpdateByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTariffsUpdateById: async (id: string, adminTariffsUpdateByIdRequest?: AdminTariffsUpdateByIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminTariffsUpdateById', 'id', id)
            const localVarPath = `/admin/tariffs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminTariffsUpdateByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTripsList: async (limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/trips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint para scraping por Prometheus. Requiere header x-metrics-token si METRICS_TOKEN estÃ¡ definido o si METRICS_PUBLIC=false.
         * @summary Prometheus metrics (public)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsPublic: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Estado de PostGIS y parÃ¡metros de matching (env) + contadores de uso.
         * @summary Diagnostics matching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDiagnosticsMatching(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminDiagnosticsMatching200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDiagnosticsMatching(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminDiagnosticsMatching']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Intenta encontrar el driver más cercano usando PostGIS si está disponible; de lo contrario cae a Haversine y finalmente idle fallback. Incrementa contadores de métricas según el camino usado.
         * @summary Probar matching (PostGIS/Haversine/Idle)
         * @param {AdminDiagnosticsMatchingTestRequest} adminDiagnosticsMatchingTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDiagnosticsMatchingTest(adminDiagnosticsMatchingTestRequest: AdminDiagnosticsMatchingTestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminDiagnosticsMatchingTest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDiagnosticsMatchingTest(adminDiagnosticsMatchingTestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminDiagnosticsMatchingTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ExposiciÃ³n de mÃ©tricas en formato Prometheus. Protegido por rol ADMIN.
         * @summary Prometheus metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminMetrics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminMetrics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Crea una regla y opcionalmente desactiva reglas activas previas de la misma ciudad.
         * @summary Crear TariffRule
         * @param {AdminTariffsCreateRequest} adminTariffsCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminTariffsCreate(adminTariffsCreateRequest: AdminTariffsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminTariffsList200ResponseItemsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminTariffsCreate(adminTariffsCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminTariffsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lista reglas por ciudad.
         * @summary Listar TariffRule
         * @param {string} [city] 
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminTariffsList(city?: string, active?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminTariffsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminTariffsList(city, active, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminTariffsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Actualiza campos de una regla por id.
         * @summary Actualizar TariffRule
         * @param {string} id 
         * @param {AdminTariffsUpdateByIdRequest} [adminTariffsUpdateByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminTariffsUpdateById(id: string, adminTariffsUpdateByIdRequest?: AdminTariffsUpdateByIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminTariffsList200ResponseItemsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminTariffsUpdateById(id, adminTariffsUpdateByIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminTariffsUpdateById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminTripsList(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminTripsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminTripsList(limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminTripsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint para scraping por Prometheus. Requiere header x-metrics-token si METRICS_TOKEN estÃ¡ definido o si METRICS_PUBLIC=false.
         * @summary Prometheus metrics (public)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsPublic(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsPublic(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.metricsPublic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Estado de PostGIS y parÃ¡metros de matching (env) + contadores de uso.
         * @summary Diagnostics matching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDiagnosticsMatching(options?: RawAxiosRequestConfig): AxiosPromise<AdminDiagnosticsMatching200Response> {
            return localVarFp.adminDiagnosticsMatching(options).then((request) => request(axios, basePath));
        },
        /**
         * Intenta encontrar el driver más cercano usando PostGIS si está disponible; de lo contrario cae a Haversine y finalmente idle fallback. Incrementa contadores de métricas según el camino usado.
         * @summary Probar matching (PostGIS/Haversine/Idle)
         * @param {AdminDiagnosticsMatchingTestRequest} adminDiagnosticsMatchingTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDiagnosticsMatchingTest(adminDiagnosticsMatchingTestRequest: AdminDiagnosticsMatchingTestRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminDiagnosticsMatchingTest200Response> {
            return localVarFp.adminDiagnosticsMatchingTest(adminDiagnosticsMatchingTestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ExposiciÃ³n de mÃ©tricas en formato Prometheus. Protegido por rol ADMIN.
         * @summary Prometheus metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminMetrics(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adminMetrics(options).then((request) => request(axios, basePath));
        },
        /**
         * Crea una regla y opcionalmente desactiva reglas activas previas de la misma ciudad.
         * @summary Crear TariffRule
         * @param {AdminTariffsCreateRequest} adminTariffsCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTariffsCreate(adminTariffsCreateRequest: AdminTariffsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminTariffsList200ResponseItemsInner> {
            return localVarFp.adminTariffsCreate(adminTariffsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Lista reglas por ciudad.
         * @summary Listar TariffRule
         * @param {string} [city] 
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTariffsList(city?: string, active?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<AdminTariffsList200Response> {
            return localVarFp.adminTariffsList(city, active, options).then((request) => request(axios, basePath));
        },
        /**
         * Actualiza campos de una regla por id.
         * @summary Actualizar TariffRule
         * @param {string} id 
         * @param {AdminTariffsUpdateByIdRequest} [adminTariffsUpdateByIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTariffsUpdateById(id: string, adminTariffsUpdateByIdRequest?: AdminTariffsUpdateByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminTariffsList200ResponseItemsInner> {
            return localVarFp.adminTariffsUpdateById(id, adminTariffsUpdateByIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminTripsList(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<AdminTripsList200Response> {
            return localVarFp.adminTripsList(limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint para scraping por Prometheus. Requiere header x-metrics-token si METRICS_TOKEN estÃ¡ definido o si METRICS_PUBLIC=false.
         * @summary Prometheus metrics (public)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsPublic(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.metricsPublic(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 */
export class AdminApi extends BaseAPI {
    /**
     * Estado de PostGIS y parÃ¡metros de matching (env) + contadores de uso.
     * @summary Diagnostics matching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminDiagnosticsMatching(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDiagnosticsMatching(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Intenta encontrar el driver más cercano usando PostGIS si está disponible; de lo contrario cae a Haversine y finalmente idle fallback. Incrementa contadores de métricas según el camino usado.
     * @summary Probar matching (PostGIS/Haversine/Idle)
     * @param {AdminDiagnosticsMatchingTestRequest} adminDiagnosticsMatchingTestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminDiagnosticsMatchingTest(adminDiagnosticsMatchingTestRequest: AdminDiagnosticsMatchingTestRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDiagnosticsMatchingTest(adminDiagnosticsMatchingTestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ExposiciÃ³n de mÃ©tricas en formato Prometheus. Protegido por rol ADMIN.
     * @summary Prometheus metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminMetrics(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminMetrics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crea una regla y opcionalmente desactiva reglas activas previas de la misma ciudad.
     * @summary Crear TariffRule
     * @param {AdminTariffsCreateRequest} adminTariffsCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminTariffsCreate(adminTariffsCreateRequest: AdminTariffsCreateRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminTariffsCreate(adminTariffsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lista reglas por ciudad.
     * @summary Listar TariffRule
     * @param {string} [city] 
     * @param {boolean} [active] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminTariffsList(city?: string, active?: boolean, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminTariffsList(city, active, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Actualiza campos de una regla por id.
     * @summary Actualizar TariffRule
     * @param {string} id 
     * @param {AdminTariffsUpdateByIdRequest} [adminTariffsUpdateByIdRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminTariffsUpdateById(id: string, adminTariffsUpdateByIdRequest?: AdminTariffsUpdateByIdRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminTariffsUpdateById(id, adminTariffsUpdateByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminTripsList(limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminTripsList(limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint para scraping por Prometheus. Requiere header x-metrics-token si METRICS_TOKEN estÃ¡ definido o si METRICS_PUBLIC=false.
     * @summary Prometheus metrics (public)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public metricsPublic(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).metricsPublic(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuthLoginRequest} authLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin: async (authLoginRequest: AuthLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authLoginRequest' is not null or undefined
            assertParamExists('authLogin', 'authLoginRequest', authLoginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthLogoutRequest} [authLogoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogout: async (authLogoutRequest?: AuthLogoutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLogoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthRefreshRequest} authRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefresh: async (authRefreshRequest: AuthRefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRefreshRequest' is not null or undefined
            assertParamExists('authRefresh', 'authRefreshRequest', authRefreshRequest)
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRefreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthRegisterRequest} authRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegister: async (authRegisterRequest: AuthRegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRegisterRequest' is not null or undefined
            assertParamExists('authRegister', 'authRegisterRequest', authRegisterRequest)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRegisterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuthLoginRequest} authLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogin(authLoginRequest: AuthLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRegister201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogin(authLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthLogoutRequest} [authLogoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogout(authLogoutRequest?: AuthLogoutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogout(authLogoutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthMe200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthRefreshRequest} authRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRefresh(authRefreshRequest: AuthRefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRefresh200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRefresh(authRefreshRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthRegisterRequest} authRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegister(authRegisterRequest: AuthRegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRegister201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegister(authRegisterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthLoginRequest} authLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin(authLoginRequest: AuthLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthRegister201Response> {
            return localVarFp.authLogin(authLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthLogoutRequest} [authLogoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogout(authLogoutRequest?: AuthLogoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthLogout200Response> {
            return localVarFp.authLogout(authLogoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMe(options?: RawAxiosRequestConfig): AxiosPromise<AuthMe200Response> {
            return localVarFp.authMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthRefreshRequest} authRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefresh(authRefreshRequest: AuthRefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthRefresh200Response> {
            return localVarFp.authRefresh(authRefreshRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthRegisterRequest} authRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegister(authRegisterRequest: AuthRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthRegister201Response> {
            return localVarFp.authRegister(authRegisterRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {AuthLoginRequest} authLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authLogin(authLoginRequest: AuthLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogin(authLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthLogoutRequest} [authLogoutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authLogout(authLogoutRequest?: AuthLogoutRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogout(authLogoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authMe(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthRefreshRequest} authRefreshRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authRefresh(authRefreshRequest: AuthRefreshRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRefresh(authRefreshRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthRegisterRequest} authRegisterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authRegister(authRegisterRequest: AuthRegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRegister(authRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthz: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/healthz`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthz(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthz(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.healthz']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthz(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.healthz(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthz(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthz(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DriversApi - axios parameter creator
 */
export const DriversApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lista viajes del driver con estado ACCEPTED/ARRIVED/STARTED.
         * @summary Mis viajes activos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        driverMyTripsActive: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/drivers/my-trips/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lista de viajes completados o cancelados para el driver autenticado.
         * @summary Mis viajes (historial)
         * @param {number} [limit] 
         * @param {string | null} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        driverMyTripsHistory: async (limit?: number, cursor?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/drivers/my-trips/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
         * @summary Actualizar estado del driver
         * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        driverUpdateLocation: async (driverUpdateStatusRequest?: DriverUpdateStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/drivers/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driverUpdateStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
         * @summary Actualizar estado del driver
         * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        driverUpdateStatus: async (driverUpdateStatusRequest?: DriverUpdateStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/drivers/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driverUpdateStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DriversApi - functional programming interface
 */
export const DriversApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DriversApiAxiosParamCreator(configuration)
    return {
        /**
         * Lista viajes del driver con estado ACCEPTED/ARRIVED/STARTED.
         * @summary Mis viajes activos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async driverMyTripsActive(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverMyTripsActive200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.driverMyTripsActive(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DriversApi.driverMyTripsActive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lista de viajes completados o cancelados para el driver autenticado.
         * @summary Mis viajes (historial)
         * @param {number} [limit] 
         * @param {string | null} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async driverMyTripsHistory(limit?: number, cursor?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverMyTripsHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.driverMyTripsHistory(limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DriversApi.driverMyTripsHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
         * @summary Actualizar estado del driver
         * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async driverUpdateLocation(driverUpdateStatusRequest?: DriverUpdateStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverUpdateStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.driverUpdateLocation(driverUpdateStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DriversApi.driverUpdateLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
         * @summary Actualizar estado del driver
         * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async driverUpdateStatus(driverUpdateStatusRequest?: DriverUpdateStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverUpdateStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.driverUpdateStatus(driverUpdateStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DriversApi.driverUpdateStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DriversApi - factory interface
 */
export const DriversApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DriversApiFp(configuration)
    return {
        /**
         * Lista viajes del driver con estado ACCEPTED/ARRIVED/STARTED.
         * @summary Mis viajes activos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        driverMyTripsActive(options?: RawAxiosRequestConfig): AxiosPromise<DriverMyTripsActive200Response> {
            return localVarFp.driverMyTripsActive(options).then((request) => request(axios, basePath));
        },
        /**
         * Lista de viajes completados o cancelados para el driver autenticado.
         * @summary Mis viajes (historial)
         * @param {number} [limit] 
         * @param {string | null} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        driverMyTripsHistory(limit?: number, cursor?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<DriverMyTripsHistory200Response> {
            return localVarFp.driverMyTripsHistory(limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
         * @summary Actualizar estado del driver
         * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        driverUpdateLocation(driverUpdateStatusRequest?: DriverUpdateStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<DriverUpdateStatus200Response> {
            return localVarFp.driverUpdateLocation(driverUpdateStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
         * @summary Actualizar estado del driver
         * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        driverUpdateStatus(driverUpdateStatusRequest?: DriverUpdateStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<DriverUpdateStatus200Response> {
            return localVarFp.driverUpdateStatus(driverUpdateStatusRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DriversApi - object-oriented interface
 */
export class DriversApi extends BaseAPI {
    /**
     * Lista viajes del driver con estado ACCEPTED/ARRIVED/STARTED.
     * @summary Mis viajes activos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public driverMyTripsActive(options?: RawAxiosRequestConfig) {
        return DriversApiFp(this.configuration).driverMyTripsActive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lista de viajes completados o cancelados para el driver autenticado.
     * @summary Mis viajes (historial)
     * @param {number} [limit] 
     * @param {string | null} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public driverMyTripsHistory(limit?: number, cursor?: string | null, options?: RawAxiosRequestConfig) {
        return DriversApiFp(this.configuration).driverMyTripsHistory(limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
     * @summary Actualizar estado del driver
     * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public driverUpdateLocation(driverUpdateStatusRequest?: DriverUpdateStatusRequest, options?: RawAxiosRequestConfig) {
        return DriversApiFp(this.configuration).driverUpdateLocation(driverUpdateStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Driver reporta su estado (IDLE/ON_TRIP/etc.). Requiere JWT.
     * @summary Actualizar estado del driver
     * @param {DriverUpdateStatusRequest} [driverUpdateStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public driverUpdateStatus(driverUpdateStatusRequest?: DriverUpdateStatusRequest, options?: RawAxiosRequestConfig) {
        return DriversApiFp(this.configuration).driverUpdateStatus(driverUpdateStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentsApi - axios parameter creator
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Agregados de pagos por fecha/ciudad/estado/m�todo. Si format=csv, devuelve text/csv.
         * @summary Reporte de pagos (ADMIN)
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {AdminPaymentsReportGroupByEnum} [groupBy] 
         * @param {AdminPaymentsReportFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPaymentsReport: async (city?: string, from?: string, to?: string, groupBy?: AdminPaymentsReportGroupByEnum, format?: AdminPaymentsReportFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/payments/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Conteo e importe por estado (PENDING/AUTHORIZED/PAID/FAILED/REFUNDED). CSV disponible.
         * @summary Resumen por estado de pago (ADMIN)
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {AdminPaymentsSummaryStatusFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPaymentsSummaryStatus: async (city?: string, from?: string, to?: string, format?: AdminPaymentsSummaryStatusFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/payments/summary-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Ingresos por driver con pagos PAID. Filtra por fecha/ciudad. CSV disponible.
         * @summary Top drivers por ingresos (ADMIN)
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {AdminPaymentsTopDriversFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPaymentsTopDrivers: async (city?: string, from?: string, to?: string, limit?: number, format?: AdminPaymentsTopDriversFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/payments/top-drivers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gasto por rider con pagos PAID. Filtra por fecha/ciudad. CSV disponible.
         * @summary Top riders por gasto (ADMIN)
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {AdminPaymentsTopRidersFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPaymentsTopRiders: async (city?: string, from?: string, to?: string, limit?: number, format?: AdminPaymentsTopRidersFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/payments/top-riders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lista auditorias de reembolso/cancelación con filtros y CSV. Si format=csv, devuelve text/csv.
         * @summary Listar refunds (ADMIN)
         * @param {string} [userId] 
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {AdminRefundsListFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRefundsList: async (userId?: string, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: AdminRefundsListFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Captura un PaymentIntent autorizado de Stripe para el trip.
         * @summary Capturar pago autorizado (ADMIN)
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCaptureByTrip: async (tripId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tripId' is not null or undefined
            assertParamExists('paymentsCaptureByTrip', 'tripId', tripId)
            const localVarPath = `/payments/{tripId}/capture`
                .replace(`{${"tripId"}}`, encodeURIComponent(String(tripId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rider crea un SetupIntent para guardar una tarjeta. Devuelve client_secret.
         * @summary Crear SetupIntent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCreateSetupIntent: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payments/setup-intent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Devuelve el registro de Payment asociado a un Trip. Requiere JWT y ser due�o del viaje o ADMIN.
         * @summary Obtener pago por tripId
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsGetByTrip: async (tripId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tripId' is not null or undefined
            assertParamExists('paymentsGetByTrip', 'tripId', tripId)
            const localVarPath = `/payments/{tripId}`
                .replace(`{${"tripId"}}`, encodeURIComponent(String(tripId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lista pagos con filtros opcionales y paginacion. Si format=csv, devuelve text/csv.
         * @summary Listar pagos (ADMIN)
         * @param {string} [userId] 
         * @param {PaymentsListStatusEnum} [status] 
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {PaymentsListFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsList: async (userId?: string, status?: PaymentsListStatusEnum, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: PaymentsListFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recibo simple del pago asociado al viaje. type=TRIP o CANCELLATION_FEE.
         * @summary Obtener recibo
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsReceiptByTrip: async (tripId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tripId' is not null or undefined
            assertParamExists('paymentsReceiptByTrip', 'tripId', tripId)
            const localVarPath = `/payments/{tripId}/receipt`
                .replace(`{${"tripId"}}`, encodeURIComponent(String(tripId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reembolsa un Payment capturado (Stripe) o cancela autorizacion. Para otros metodos, marca REFUNDED y registra auditoria.
         * @summary Refund/cancel (ADMIN)
         * @param {string} tripId 
         * @param {PaymentsRefundByTripRequest} [paymentsRefundByTripRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsRefundByTrip: async (tripId: string, paymentsRefundByTripRequest?: PaymentsRefundByTripRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tripId' is not null or undefined
            assertParamExists('paymentsRefundByTrip', 'tripId', tripId)
            const localVarPath = `/payments/{tripId}/refund`
                .replace(`{${"tripId"}}`, encodeURIComponent(String(tripId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentsRefundByTripRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lista auditorias de reembolso/cancelación del pago de un trip. Requiere JWT y ser due�o del viaje o ADMIN.
         * @summary Refunds por tripId
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsRefundsByTrip: async (tripId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tripId' is not null or undefined
            assertParamExists('paymentsRefundsByTrip', 'tripId', tripId)
            const localVarPath = `/payments/{tripId}/refunds`
                .replace(`{${"tripId"}}`, encodeURIComponent(String(tripId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Guarda el paymentMethod como predeterminado en Stripe y DB.
         * @summary Definir PM por defecto
         * @param {PaymentsSetDefaultMethodRequest} paymentsSetDefaultMethodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsSetDefaultMethod: async (paymentsSetDefaultMethodRequest: PaymentsSetDefaultMethodRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentsSetDefaultMethodRequest' is not null or undefined
            assertParamExists('paymentsSetDefaultMethod', 'paymentsSetDefaultMethodRequest', paymentsSetDefaultMethodRequest)
            const localVarPath = `/payments/set-default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentsSetDefaultMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stripe webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksStripe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks/stripe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Agregados de pagos por fecha/ciudad/estado/m�todo. Si format=csv, devuelve text/csv.
         * @summary Reporte de pagos (ADMIN)
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {AdminPaymentsReportGroupByEnum} [groupBy] 
         * @param {AdminPaymentsReportFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminPaymentsReport(city?: string, from?: string, to?: string, groupBy?: AdminPaymentsReportGroupByEnum, format?: AdminPaymentsReportFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminPaymentsReport200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminPaymentsReport(city, from, to, groupBy, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.adminPaymentsReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Conteo e importe por estado (PENDING/AUTHORIZED/PAID/FAILED/REFUNDED). CSV disponible.
         * @summary Resumen por estado de pago (ADMIN)
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {AdminPaymentsSummaryStatusFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminPaymentsSummaryStatus(city?: string, from?: string, to?: string, format?: AdminPaymentsSummaryStatusFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminPaymentsSummaryStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminPaymentsSummaryStatus(city, from, to, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.adminPaymentsSummaryStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Ingresos por driver con pagos PAID. Filtra por fecha/ciudad. CSV disponible.
         * @summary Top drivers por ingresos (ADMIN)
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {AdminPaymentsTopDriversFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminPaymentsTopDrivers(city?: string, from?: string, to?: string, limit?: number, format?: AdminPaymentsTopDriversFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminPaymentsTopDrivers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminPaymentsTopDrivers(city, from, to, limit, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.adminPaymentsTopDrivers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gasto por rider con pagos PAID. Filtra por fecha/ciudad. CSV disponible.
         * @summary Top riders por gasto (ADMIN)
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {AdminPaymentsTopRidersFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminPaymentsTopRiders(city?: string, from?: string, to?: string, limit?: number, format?: AdminPaymentsTopRidersFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminPaymentsTopRiders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminPaymentsTopRiders(city, from, to, limit, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.adminPaymentsTopRiders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lista auditorias de reembolso/cancelación con filtros y CSV. Si format=csv, devuelve text/csv.
         * @summary Listar refunds (ADMIN)
         * @param {string} [userId] 
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {AdminRefundsListFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminRefundsList(userId?: string, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: AdminRefundsListFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminRefundsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminRefundsList(userId, city, from, to, limit, cursor, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.adminRefundsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Captura un PaymentIntent autorizado de Stripe para el trip.
         * @summary Capturar pago autorizado (ADMIN)
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsCaptureByTrip(tripId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverUpdateStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsCaptureByTrip(tripId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsCaptureByTrip']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rider crea un SetupIntent para guardar una tarjeta. Devuelve client_secret.
         * @summary Crear SetupIntent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsCreateSetupIntent(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsCreateSetupIntent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsCreateSetupIntent(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsCreateSetupIntent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Devuelve el registro de Payment asociado a un Trip. Requiere JWT y ser due�o del viaje o ADMIN.
         * @summary Obtener pago por tripId
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsGetByTrip(tripId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsList200ResponseItemsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsGetByTrip(tripId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsGetByTrip']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lista pagos con filtros opcionales y paginacion. Si format=csv, devuelve text/csv.
         * @summary Listar pagos (ADMIN)
         * @param {string} [userId] 
         * @param {PaymentsListStatusEnum} [status] 
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {PaymentsListFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsList(userId?: string, status?: PaymentsListStatusEnum, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: PaymentsListFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsList(userId, status, city, from, to, limit, cursor, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recibo simple del pago asociado al viaje. type=TRIP o CANCELLATION_FEE.
         * @summary Obtener recibo
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsReceiptByTrip(tripId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsReceiptByTrip200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsReceiptByTrip(tripId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsReceiptByTrip']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reembolsa un Payment capturado (Stripe) o cancela autorizacion. Para otros metodos, marca REFUNDED y registra auditoria.
         * @summary Refund/cancel (ADMIN)
         * @param {string} tripId 
         * @param {PaymentsRefundByTripRequest} [paymentsRefundByTripRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsRefundByTrip(tripId: string, paymentsRefundByTripRequest?: PaymentsRefundByTripRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverUpdateStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsRefundByTrip(tripId, paymentsRefundByTripRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsRefundByTrip']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lista auditorias de reembolso/cancelación del pago de un trip. Requiere JWT y ser due�o del viaje o ADMIN.
         * @summary Refunds por tripId
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsRefundsByTrip(tripId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsRefundsByTrip200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsRefundsByTrip(tripId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsRefundsByTrip']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Guarda el paymentMethod como predeterminado en Stripe y DB.
         * @summary Definir PM por defecto
         * @param {PaymentsSetDefaultMethodRequest} paymentsSetDefaultMethodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsSetDefaultMethod(paymentsSetDefaultMethodRequest: PaymentsSetDefaultMethodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsSetDefaultMethod(paymentsSetDefaultMethodRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.paymentsSetDefaultMethod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stripe webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksStripe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksStripe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.webhooksStripe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentsApi - factory interface
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * Agregados de pagos por fecha/ciudad/estado/m�todo. Si format=csv, devuelve text/csv.
         * @summary Reporte de pagos (ADMIN)
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {AdminPaymentsReportGroupByEnum} [groupBy] 
         * @param {AdminPaymentsReportFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPaymentsReport(city?: string, from?: string, to?: string, groupBy?: AdminPaymentsReportGroupByEnum, format?: AdminPaymentsReportFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<AdminPaymentsReport200Response> {
            return localVarFp.adminPaymentsReport(city, from, to, groupBy, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Conteo e importe por estado (PENDING/AUTHORIZED/PAID/FAILED/REFUNDED). CSV disponible.
         * @summary Resumen por estado de pago (ADMIN)
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {AdminPaymentsSummaryStatusFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPaymentsSummaryStatus(city?: string, from?: string, to?: string, format?: AdminPaymentsSummaryStatusFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<AdminPaymentsSummaryStatus200Response> {
            return localVarFp.adminPaymentsSummaryStatus(city, from, to, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Ingresos por driver con pagos PAID. Filtra por fecha/ciudad. CSV disponible.
         * @summary Top drivers por ingresos (ADMIN)
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {AdminPaymentsTopDriversFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPaymentsTopDrivers(city?: string, from?: string, to?: string, limit?: number, format?: AdminPaymentsTopDriversFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<AdminPaymentsTopDrivers200Response> {
            return localVarFp.adminPaymentsTopDrivers(city, from, to, limit, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Gasto por rider con pagos PAID. Filtra por fecha/ciudad. CSV disponible.
         * @summary Top riders por gasto (ADMIN)
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {AdminPaymentsTopRidersFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPaymentsTopRiders(city?: string, from?: string, to?: string, limit?: number, format?: AdminPaymentsTopRidersFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<AdminPaymentsTopRiders200Response> {
            return localVarFp.adminPaymentsTopRiders(city, from, to, limit, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Lista auditorias de reembolso/cancelación con filtros y CSV. Si format=csv, devuelve text/csv.
         * @summary Listar refunds (ADMIN)
         * @param {string} [userId] 
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {AdminRefundsListFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRefundsList(userId?: string, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: AdminRefundsListFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<AdminRefundsList200Response> {
            return localVarFp.adminRefundsList(userId, city, from, to, limit, cursor, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Captura un PaymentIntent autorizado de Stripe para el trip.
         * @summary Capturar pago autorizado (ADMIN)
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCaptureByTrip(tripId: string, options?: RawAxiosRequestConfig): AxiosPromise<DriverUpdateStatus200Response> {
            return localVarFp.paymentsCaptureByTrip(tripId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rider crea un SetupIntent para guardar una tarjeta. Devuelve client_secret.
         * @summary Crear SetupIntent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCreateSetupIntent(options?: RawAxiosRequestConfig): AxiosPromise<PaymentsCreateSetupIntent200Response> {
            return localVarFp.paymentsCreateSetupIntent(options).then((request) => request(axios, basePath));
        },
        /**
         * Devuelve el registro de Payment asociado a un Trip. Requiere JWT y ser due�o del viaje o ADMIN.
         * @summary Obtener pago por tripId
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsGetByTrip(tripId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsList200ResponseItemsInner> {
            return localVarFp.paymentsGetByTrip(tripId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lista pagos con filtros opcionales y paginacion. Si format=csv, devuelve text/csv.
         * @summary Listar pagos (ADMIN)
         * @param {string} [userId] 
         * @param {PaymentsListStatusEnum} [status] 
         * @param {string} [city] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {PaymentsListFormatEnum} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsList(userId?: string, status?: PaymentsListStatusEnum, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: PaymentsListFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsList200Response> {
            return localVarFp.paymentsList(userId, status, city, from, to, limit, cursor, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Recibo simple del pago asociado al viaje. type=TRIP o CANCELLATION_FEE.
         * @summary Obtener recibo
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsReceiptByTrip(tripId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsReceiptByTrip200Response> {
            return localVarFp.paymentsReceiptByTrip(tripId, options).then((request) => request(axios, basePath));
        },
        /**
         * Reembolsa un Payment capturado (Stripe) o cancela autorizacion. Para otros metodos, marca REFUNDED y registra auditoria.
         * @summary Refund/cancel (ADMIN)
         * @param {string} tripId 
         * @param {PaymentsRefundByTripRequest} [paymentsRefundByTripRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsRefundByTrip(tripId: string, paymentsRefundByTripRequest?: PaymentsRefundByTripRequest, options?: RawAxiosRequestConfig): AxiosPromise<DriverUpdateStatus200Response> {
            return localVarFp.paymentsRefundByTrip(tripId, paymentsRefundByTripRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Lista auditorias de reembolso/cancelación del pago de un trip. Requiere JWT y ser due�o del viaje o ADMIN.
         * @summary Refunds por tripId
         * @param {string} tripId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsRefundsByTrip(tripId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsRefundsByTrip200Response> {
            return localVarFp.paymentsRefundsByTrip(tripId, options).then((request) => request(axios, basePath));
        },
        /**
         * Guarda el paymentMethod como predeterminado en Stripe y DB.
         * @summary Definir PM por defecto
         * @param {PaymentsSetDefaultMethodRequest} paymentsSetDefaultMethodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsSetDefaultMethod(paymentsSetDefaultMethodRequest: PaymentsSetDefaultMethodRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthLogout200Response> {
            return localVarFp.paymentsSetDefaultMethod(paymentsSetDefaultMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stripe webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksStripe(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.webhooksStripe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 */
export class PaymentsApi extends BaseAPI {
    /**
     * Agregados de pagos por fecha/ciudad/estado/m�todo. Si format=csv, devuelve text/csv.
     * @summary Reporte de pagos (ADMIN)
     * @param {string} [city] 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {AdminPaymentsReportGroupByEnum} [groupBy] 
     * @param {AdminPaymentsReportFormatEnum} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminPaymentsReport(city?: string, from?: string, to?: string, groupBy?: AdminPaymentsReportGroupByEnum, format?: AdminPaymentsReportFormatEnum, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).adminPaymentsReport(city, from, to, groupBy, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Conteo e importe por estado (PENDING/AUTHORIZED/PAID/FAILED/REFUNDED). CSV disponible.
     * @summary Resumen por estado de pago (ADMIN)
     * @param {string} [city] 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {AdminPaymentsSummaryStatusFormatEnum} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminPaymentsSummaryStatus(city?: string, from?: string, to?: string, format?: AdminPaymentsSummaryStatusFormatEnum, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).adminPaymentsSummaryStatus(city, from, to, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Ingresos por driver con pagos PAID. Filtra por fecha/ciudad. CSV disponible.
     * @summary Top drivers por ingresos (ADMIN)
     * @param {string} [city] 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {number} [limit] 
     * @param {AdminPaymentsTopDriversFormatEnum} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminPaymentsTopDrivers(city?: string, from?: string, to?: string, limit?: number, format?: AdminPaymentsTopDriversFormatEnum, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).adminPaymentsTopDrivers(city, from, to, limit, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gasto por rider con pagos PAID. Filtra por fecha/ciudad. CSV disponible.
     * @summary Top riders por gasto (ADMIN)
     * @param {string} [city] 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {number} [limit] 
     * @param {AdminPaymentsTopRidersFormatEnum} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminPaymentsTopRiders(city?: string, from?: string, to?: string, limit?: number, format?: AdminPaymentsTopRidersFormatEnum, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).adminPaymentsTopRiders(city, from, to, limit, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lista auditorias de reembolso/cancelación con filtros y CSV. Si format=csv, devuelve text/csv.
     * @summary Listar refunds (ADMIN)
     * @param {string} [userId] 
     * @param {string} [city] 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {AdminRefundsListFormatEnum} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminRefundsList(userId?: string, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: AdminRefundsListFormatEnum, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).adminRefundsList(userId, city, from, to, limit, cursor, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Captura un PaymentIntent autorizado de Stripe para el trip.
     * @summary Capturar pago autorizado (ADMIN)
     * @param {string} tripId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsCaptureByTrip(tripId: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsCaptureByTrip(tripId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rider crea un SetupIntent para guardar una tarjeta. Devuelve client_secret.
     * @summary Crear SetupIntent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsCreateSetupIntent(options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsCreateSetupIntent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Devuelve el registro de Payment asociado a un Trip. Requiere JWT y ser due�o del viaje o ADMIN.
     * @summary Obtener pago por tripId
     * @param {string} tripId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsGetByTrip(tripId: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsGetByTrip(tripId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lista pagos con filtros opcionales y paginacion. Si format=csv, devuelve text/csv.
     * @summary Listar pagos (ADMIN)
     * @param {string} [userId] 
     * @param {PaymentsListStatusEnum} [status] 
     * @param {string} [city] 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {PaymentsListFormatEnum} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsList(userId?: string, status?: PaymentsListStatusEnum, city?: string, from?: string, to?: string, limit?: number, cursor?: string, format?: PaymentsListFormatEnum, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsList(userId, status, city, from, to, limit, cursor, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recibo simple del pago asociado al viaje. type=TRIP o CANCELLATION_FEE.
     * @summary Obtener recibo
     * @param {string} tripId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsReceiptByTrip(tripId: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsReceiptByTrip(tripId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reembolsa un Payment capturado (Stripe) o cancela autorizacion. Para otros metodos, marca REFUNDED y registra auditoria.
     * @summary Refund/cancel (ADMIN)
     * @param {string} tripId 
     * @param {PaymentsRefundByTripRequest} [paymentsRefundByTripRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsRefundByTrip(tripId: string, paymentsRefundByTripRequest?: PaymentsRefundByTripRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsRefundByTrip(tripId, paymentsRefundByTripRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lista auditorias de reembolso/cancelación del pago de un trip. Requiere JWT y ser due�o del viaje o ADMIN.
     * @summary Refunds por tripId
     * @param {string} tripId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsRefundsByTrip(tripId: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsRefundsByTrip(tripId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Guarda el paymentMethod como predeterminado en Stripe y DB.
     * @summary Definir PM por defecto
     * @param {PaymentsSetDefaultMethodRequest} paymentsSetDefaultMethodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentsSetDefaultMethod(paymentsSetDefaultMethodRequest: PaymentsSetDefaultMethodRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsSetDefaultMethod(paymentsSetDefaultMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stripe webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksStripe(options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).webhooksStripe(options).then((request) => request(this.axios, this.basePath));
    }
}

export const AdminPaymentsReportGroupByEnum = {
    Day: 'day',
    City: 'city',
    Status: 'status',
    CityDay: 'city_day',
    Method: 'method'
} as const;
export type AdminPaymentsReportGroupByEnum = typeof AdminPaymentsReportGroupByEnum[keyof typeof AdminPaymentsReportGroupByEnum];
export const AdminPaymentsReportFormatEnum = {
    Json: 'json',
    Csv: 'csv'
} as const;
export type AdminPaymentsReportFormatEnum = typeof AdminPaymentsReportFormatEnum[keyof typeof AdminPaymentsReportFormatEnum];
export const AdminPaymentsSummaryStatusFormatEnum = {
    Json: 'json',
    Csv: 'csv'
} as const;
export type AdminPaymentsSummaryStatusFormatEnum = typeof AdminPaymentsSummaryStatusFormatEnum[keyof typeof AdminPaymentsSummaryStatusFormatEnum];
export const AdminPaymentsTopDriversFormatEnum = {
    Json: 'json',
    Csv: 'csv'
} as const;
export type AdminPaymentsTopDriversFormatEnum = typeof AdminPaymentsTopDriversFormatEnum[keyof typeof AdminPaymentsTopDriversFormatEnum];
export const AdminPaymentsTopRidersFormatEnum = {
    Json: 'json',
    Csv: 'csv'
} as const;
export type AdminPaymentsTopRidersFormatEnum = typeof AdminPaymentsTopRidersFormatEnum[keyof typeof AdminPaymentsTopRidersFormatEnum];
export const AdminRefundsListFormatEnum = {
    Json: 'json',
    Csv: 'csv'
} as const;
export type AdminRefundsListFormatEnum = typeof AdminRefundsListFormatEnum[keyof typeof AdminRefundsListFormatEnum];
export const PaymentsListStatusEnum = {
    Pending: 'PENDING',
    Authorized: 'AUTHORIZED',
    Paid: 'PAID',
    Failed: 'FAILED',
    Refunded: 'REFUNDED'
} as const;
export type PaymentsListStatusEnum = typeof PaymentsListStatusEnum[keyof typeof PaymentsListStatusEnum];
export const PaymentsListFormatEnum = {
    Json: 'json',
    Csv: 'csv'
} as const;
export type PaymentsListFormatEnum = typeof PaymentsListFormatEnum[keyof typeof PaymentsListFormatEnum];


/**
 * RiderApi - axios parameter creator
 */
export const RiderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lista los últimos viajes del rider autenticado.
         * @summary Mis viajes (rider)
         * @param {number} [limit] 
         * @param {string | null} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        riderMyTrips: async (limit?: number, cursor?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rider/my-trips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RiderApi - functional programming interface
 */
export const RiderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RiderApiAxiosParamCreator(configuration)
    return {
        /**
         * Lista los últimos viajes del rider autenticado.
         * @summary Mis viajes (rider)
         * @param {number} [limit] 
         * @param {string | null} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async riderMyTrips(limit?: number, cursor?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RiderMyTrips200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.riderMyTrips(limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RiderApi.riderMyTrips']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RiderApi - factory interface
 */
export const RiderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RiderApiFp(configuration)
    return {
        /**
         * Lista los últimos viajes del rider autenticado.
         * @summary Mis viajes (rider)
         * @param {number} [limit] 
         * @param {string | null} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        riderMyTrips(limit?: number, cursor?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<RiderMyTrips200Response> {
            return localVarFp.riderMyTrips(limit, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RiderApi - object-oriented interface
 */
export class RiderApi extends BaseAPI {
    /**
     * Lista los últimos viajes del rider autenticado.
     * @summary Mis viajes (rider)
     * @param {number} [limit] 
     * @param {string | null} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public riderMyTrips(limit?: number, cursor?: string | null, options?: RawAxiosRequestConfig) {
        return RiderApiFp(this.configuration).riderMyTrips(limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TripsApi - axios parameter creator
 */
export const TripsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * El conductor acepta el viaje asignado.
         * @summary Aceptar viaje
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsAccept: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tripsAccept', 'id', id)
            const localVarPath = `/trips/{id}/accept`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * El conductor llegï¿½ al punto de recogida.
         * @summary Arribo del conductor
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsArrived: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tripsArrived', 'id', id)
            const localVarPath = `/trips/{id}/arrived`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * El rider cancela el viaje; puede aplicar fee segï¿½n estado y reglas.
         * @summary Cancelar viaje (rider)
         * @param {string} id 
         * @param {TripsCancelRequest} [tripsCancelRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsCancel: async (id: string, tripsCancelRequest?: TripsCancelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tripsCancel', 'id', id)
            const localVarPath = `/trips/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tripsCancelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completa el viaje y liquida el pago (captura Stripe o marca CASH pagado).
         * @summary Completar viaje
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsComplete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tripsComplete', 'id', id)
            const localVarPath = `/trips/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Devuelve lat/lng y timestamp de la Ãºltima ubicaciï¿½n reportada por el driver asignado al trip.
         * @summary UbicaciÃ³n actual del driver para el viaje
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsDriverLocation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tripsDriverLocation', 'id', id)
            const localVarPath = `/trips/{id}/driver-location`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crea un viaje y asigna el conductor disponible mÃ¡s cercano.
         * @summary Solicitar viaje
         * @param {TripsRequestRequest} tripsRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsRequest: async (tripsRequestRequest: TripsRequestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tripsRequestRequest' is not null or undefined
            assertParamExists('tripsRequest', 'tripsRequestRequest', tripsRequestRequest)
            const localVarPath = `/trips/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tripsRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stream de eventos del viaje en tiempo real para Rider/Driver via Server-Sent Events. EnvÃ­a eventos como INIT/ASSIGNED/ACCEPTED/ARRIVED/STARTED/COMPLETED/CANCELED y LOCATION (lat/lng del driver).
         * @summary Trip live updates (SSE)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsSseById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tripsSseById', 'id', id)
            const localVarPath = `/trips/{id}/sse`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inicia el viaje; si method=CARD y Stripe estï¿½ configurado, preautoriza.
         * @summary Iniciar viaje
         * @param {string} id 
         * @param {TripsStartRequest} [tripsStartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsStart: async (id: string, tripsStartRequest?: TripsStartRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tripsStart', 'id', id)
            const localVarPath = `/trips/{id}/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tripsStartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TripsApi - functional programming interface
 */
export const TripsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TripsApiAxiosParamCreator(configuration)
    return {
        /**
         * El conductor acepta el viaje asignado.
         * @summary Aceptar viaje
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsAccept(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripsRequest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsAccept(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TripsApi.tripsAccept']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * El conductor llegï¿½ al punto de recogida.
         * @summary Arribo del conductor
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsArrived(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripsArrived200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsArrived(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TripsApi.tripsArrived']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * El rider cancela el viaje; puede aplicar fee segï¿½n estado y reglas.
         * @summary Cancelar viaje (rider)
         * @param {string} id 
         * @param {TripsCancelRequest} [tripsCancelRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsCancel(id: string, tripsCancelRequest?: TripsCancelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripsCancel200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsCancel(id, tripsCancelRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TripsApi.tripsCancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completa el viaje y liquida el pago (captura Stripe o marca CASH pagado).
         * @summary Completar viaje
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsComplete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripsComplete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsComplete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TripsApi.tripsComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Devuelve lat/lng y timestamp de la Ãºltima ubicaciï¿½n reportada por el driver asignado al trip.
         * @summary UbicaciÃ³n actual del driver para el viaje
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsDriverLocation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripsDriverLocation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsDriverLocation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TripsApi.tripsDriverLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Crea un viaje y asigna el conductor disponible mÃ¡s cercano.
         * @summary Solicitar viaje
         * @param {TripsRequestRequest} tripsRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsRequest(tripsRequestRequest: TripsRequestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripsRequest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsRequest(tripsRequestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TripsApi.tripsRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stream de eventos del viaje en tiempo real para Rider/Driver via Server-Sent Events. EnvÃ­a eventos como INIT/ASSIGNED/ACCEPTED/ARRIVED/STARTED/COMPLETED/CANCELED y LOCATION (lat/lng del driver).
         * @summary Trip live updates (SSE)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsSseById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsSseById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TripsApi.tripsSseById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Inicia el viaje; si method=CARD y Stripe estï¿½ configurado, preautoriza.
         * @summary Iniciar viaje
         * @param {string} id 
         * @param {TripsStartRequest} [tripsStartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsStart(id: string, tripsStartRequest?: TripsStartRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripsStart200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsStart(id, tripsStartRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TripsApi.tripsStart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TripsApi - factory interface
 */
export const TripsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TripsApiFp(configuration)
    return {
        /**
         * El conductor acepta el viaje asignado.
         * @summary Aceptar viaje
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsAccept(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TripsRequest200Response> {
            return localVarFp.tripsAccept(id, options).then((request) => request(axios, basePath));
        },
        /**
         * El conductor llegï¿½ al punto de recogida.
         * @summary Arribo del conductor
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsArrived(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TripsArrived200Response> {
            return localVarFp.tripsArrived(id, options).then((request) => request(axios, basePath));
        },
        /**
         * El rider cancela el viaje; puede aplicar fee segï¿½n estado y reglas.
         * @summary Cancelar viaje (rider)
         * @param {string} id 
         * @param {TripsCancelRequest} [tripsCancelRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsCancel(id: string, tripsCancelRequest?: TripsCancelRequest, options?: RawAxiosRequestConfig): AxiosPromise<TripsCancel200Response> {
            return localVarFp.tripsCancel(id, tripsCancelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Completa el viaje y liquida el pago (captura Stripe o marca CASH pagado).
         * @summary Completar viaje
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsComplete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TripsComplete200Response> {
            return localVarFp.tripsComplete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Devuelve lat/lng y timestamp de la Ãºltima ubicaciï¿½n reportada por el driver asignado al trip.
         * @summary UbicaciÃ³n actual del driver para el viaje
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsDriverLocation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TripsDriverLocation200Response> {
            return localVarFp.tripsDriverLocation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Crea un viaje y asigna el conductor disponible mÃ¡s cercano.
         * @summary Solicitar viaje
         * @param {TripsRequestRequest} tripsRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsRequest(tripsRequestRequest: TripsRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<TripsRequest200Response> {
            return localVarFp.tripsRequest(tripsRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Stream de eventos del viaje en tiempo real para Rider/Driver via Server-Sent Events. EnvÃ­a eventos como INIT/ASSIGNED/ACCEPTED/ARRIVED/STARTED/COMPLETED/CANCELED y LOCATION (lat/lng del driver).
         * @summary Trip live updates (SSE)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsSseById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.tripsSseById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Inicia el viaje; si method=CARD y Stripe estï¿½ configurado, preautoriza.
         * @summary Iniciar viaje
         * @param {string} id 
         * @param {TripsStartRequest} [tripsStartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsStart(id: string, tripsStartRequest?: TripsStartRequest, options?: RawAxiosRequestConfig): AxiosPromise<TripsStart200Response> {
            return localVarFp.tripsStart(id, tripsStartRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TripsApi - object-oriented interface
 */
export class TripsApi extends BaseAPI {
    /**
     * El conductor acepta el viaje asignado.
     * @summary Aceptar viaje
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tripsAccept(id: string, options?: RawAxiosRequestConfig) {
        return TripsApiFp(this.configuration).tripsAccept(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * El conductor llegï¿½ al punto de recogida.
     * @summary Arribo del conductor
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tripsArrived(id: string, options?: RawAxiosRequestConfig) {
        return TripsApiFp(this.configuration).tripsArrived(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * El rider cancela el viaje; puede aplicar fee segï¿½n estado y reglas.
     * @summary Cancelar viaje (rider)
     * @param {string} id 
     * @param {TripsCancelRequest} [tripsCancelRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tripsCancel(id: string, tripsCancelRequest?: TripsCancelRequest, options?: RawAxiosRequestConfig) {
        return TripsApiFp(this.configuration).tripsCancel(id, tripsCancelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completa el viaje y liquida el pago (captura Stripe o marca CASH pagado).
     * @summary Completar viaje
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tripsComplete(id: string, options?: RawAxiosRequestConfig) {
        return TripsApiFp(this.configuration).tripsComplete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Devuelve lat/lng y timestamp de la Ãºltima ubicaciï¿½n reportada por el driver asignado al trip.
     * @summary UbicaciÃ³n actual del driver para el viaje
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tripsDriverLocation(id: string, options?: RawAxiosRequestConfig) {
        return TripsApiFp(this.configuration).tripsDriverLocation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crea un viaje y asigna el conductor disponible mÃ¡s cercano.
     * @summary Solicitar viaje
     * @param {TripsRequestRequest} tripsRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tripsRequest(tripsRequestRequest: TripsRequestRequest, options?: RawAxiosRequestConfig) {
        return TripsApiFp(this.configuration).tripsRequest(tripsRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stream de eventos del viaje en tiempo real para Rider/Driver via Server-Sent Events. EnvÃ­a eventos como INIT/ASSIGNED/ACCEPTED/ARRIVED/STARTED/COMPLETED/CANCELED y LOCATION (lat/lng del driver).
     * @summary Trip live updates (SSE)
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tripsSseById(id: string, options?: RawAxiosRequestConfig) {
        return TripsApiFp(this.configuration).tripsSseById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inicia el viaje; si method=CARD y Stripe estï¿½ configurado, preautoriza.
     * @summary Iniciar viaje
     * @param {string} id 
     * @param {TripsStartRequest} [tripsStartRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tripsStart(id: string, tripsStartRequest?: TripsStartRequest, options?: RawAxiosRequestConfig) {
        return TripsApiFp(this.configuration).tripsStart(id, tripsStartRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Borra el FCM token asociado al usuario (logout de push notifications).
         * @summary Eliminar FCM token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeletePushToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/push-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registra o actualiza el FCM token del usuario logueado.
         * @summary Registrar FCM token
         * @param {UsersRegisterPushTokenRequest} usersRegisterPushTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRegisterPushToken: async (usersRegisterPushTokenRequest: UsersRegisterPushTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersRegisterPushTokenRequest' is not null or undefined
            assertParamExists('usersRegisterPushToken', 'usersRegisterPushTokenRequest', usersRegisterPushTokenRequest)
            const localVarPath = `/users/me/push-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersRegisterPushTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Borra el FCM token asociado al usuario (logout de push notifications).
         * @summary Eliminar FCM token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDeletePushToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverUpdateStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDeletePushToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersDeletePushToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Registra o actualiza el FCM token del usuario logueado.
         * @summary Registrar FCM token
         * @param {UsersRegisterPushTokenRequest} usersRegisterPushTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRegisterPushToken(usersRegisterPushTokenRequest: UsersRegisterPushTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverUpdateStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersRegisterPushToken(usersRegisterPushTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersRegisterPushToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Borra el FCM token asociado al usuario (logout de push notifications).
         * @summary Eliminar FCM token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeletePushToken(options?: RawAxiosRequestConfig): AxiosPromise<DriverUpdateStatus200Response> {
            return localVarFp.usersDeletePushToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Registra o actualiza el FCM token del usuario logueado.
         * @summary Registrar FCM token
         * @param {UsersRegisterPushTokenRequest} usersRegisterPushTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRegisterPushToken(usersRegisterPushTokenRequest: UsersRegisterPushTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<DriverUpdateStatus200Response> {
            return localVarFp.usersRegisterPushToken(usersRegisterPushTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * Borra el FCM token asociado al usuario (logout de push notifications).
     * @summary Eliminar FCM token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersDeletePushToken(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDeletePushToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registra o actualiza el FCM token del usuario logueado.
     * @summary Registrar FCM token
     * @param {UsersRegisterPushTokenRequest} usersRegisterPushTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersRegisterPushToken(usersRegisterPushTokenRequest: UsersRegisterPushTokenRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersRegisterPushToken(usersRegisterPushTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



