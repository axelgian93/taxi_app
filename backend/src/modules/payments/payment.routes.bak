// src/modules/payments/payment.routes.ts
import type { FastifyInstance } from 'fastify'

import prisma from '../../lib/prisma'

export default async function paymentRoutes(app: FastifyInstance) {
  const idParamSchema = {
    type: 'object',
    required: ['tripId'],
    properties: { tripId: { type: 'string', example: 'trp_123' } },
    additionalProperties: false,
  } as const

  const errorSchema = { type: 'object', properties: { error: { type: 'string' } } } as const
  const paymentSchema = {
    type: 'object',
    properties: {
      id: { type: 'string' },
      tripId: { type: 'string' },
      amountUsd: { type: 'number' },
      status: { type: 'string', enum: ['PENDING','AUTHORIZED','PAID','FAILED','REFUNDED'] },
      method: { type: 'string' },
      provider: { type: 'string', nullable: true },
      externalId: { type: 'string', nullable: true },
      createdAt: { type: 'string', format: 'date-time' },
      updatedAt: { type: 'string', format: 'date-time' },
      // Derived flags for client simplicity
      isAuthorized: { type: 'boolean' },
      isPaid: { type: 'boolean' },
      isFailed: { type: 'boolean' },
      providerDisplay: { type: 'string' },
      capturable: { type: 'boolean' },
    },
    example: {
      id: 'pay_123', tripId: 'trp_123', amountUsd: 7.8, status: 'PAID', method: 'CASH', provider: null, externalId: null,
      isAuthorized: false, isPaid: true, isFailed: false, providerDisplay: 'Cash', capturable: false,
      createdAt: '2025-01-01T12:20:00.000Z', updatedAt: '2025-01-01T12:20:00.000Z'
    }
  } as const

  // Admin list payments with filters
  const listQuery = {
    type: 'object',
    properties: {
      userId: { type: 'string' },
      status: { type: 'string', enum: ['PENDING','AUTHORIZED','PAID','FAILED','REFUNDED'] },
      city: { type: 'string' },
      from: { type: 'string', format: 'date-time' },
      to: { type: 'string', format: 'date-time' },
      limit: { type: 'integer', minimum: 1, maximum: 200, default: 50 },
      cursor: { type: 'string' },
      format: { type: 'string', enum: ['json','csv'], default: 'json' },
    },
    additionalProperties: false,
  } as const

  app.get(
    '/payments',
    { schema: { operationId: 'paymentsList', tags: ['payments'], summary: 'Listar pagos (ADMIN)', description: 'Lista pagos con filtros opcionales y paginacion. Si format=csv, devuelve text/csv.', querystring: listQuery, response: { 200: { content: { 'application/json': { schema: { type: 'object', properties: { items: { type: 'array', items: paymentSchema }, nextCursor: { type: 'string', nullable: true } }, example: { items: [paymentSchema.example], nextCursor: null } } }, 'text/csv': { schema: { type: 'string', example: 'id,tripId,amountUsd,status,method,provider,externalId,createdAt,updatedAt,isAuthorized,isPaid,isFailed,providerDisplay,capturable\n"pay_123","trp_123",7.8,"PAID","CASH","","","2025-01-01T12:20:00.000Z","2025-01-01T12:20:00.000Z",false,true,false,"Cash",false\n' } } } } } }, preHandler: app.auth.requireRole('ADMIN') },
    async (req: any, reply) => {
      const { userId, status, city, from, to, limit = 50, cursor, format = 'json' } = req.query as { userId?: string; status?: any; city?: string; from?: string; to?: string; limit?: number; cursor?: string; format?: 'json'|'csv' }
      const where: any = {}
      if (status) where.status = status
      if (from || to) where.createdAt = { ...(from ? { gte: new Date(from) } : {}), ...(to ? { lte: new Date(to) } : {}) }
      if (userId) {
        // Join via Trip to filter by rider/driver involvement
        where.trip = { OR: [ { riderId: userId }, { driverId: userId } ] }
      }
      if (city) {
        // Filter by Trip.pricingSnapshot.city when available
        where.trip = {
          ...(where.trip || {}),
          pricingSnapshot: { path: ['city'], equals: city } as any,
        }
      }
      const items = await prisma.payment.findMany({
        where,
        take: limit,
        ...(cursor ? { skip: 1, cursor: { id: cursor } } : {}),
        orderBy: { createdAt: 'desc' },
      })
      const mapped = items.map((payment) => {
        const isAuthorized = payment.status === 'AUTHORIZED'
        const isPaid = payment.status === 'PAID'
        const isFailed = payment.status === 'FAILED'
        const providerDisplay = payment.provider === 'Stripe' ? 'Stripe' : payment.method === 'CASH' ? 'Cash' : payment.method === 'TRANSFER' ? 'Bank' : (payment.provider || 'Unknown')
        const capturable = payment.provider === 'Stripe' && payment.status === 'AUTHORIZED' && Boolean(payment.externalId)
        return { ...payment, isAuthorized, isPaid, isFailed, providerDisplay, capturable }
      })
      if (format === 'csv') {
        const header = ['id','tripId','amountUsd','status','method','provider','externalId','createdAt','updatedAt','isAuthorized','isPaid','isFailed','providerDisplay','capturable']
        const rows = mapped.map(p => [
          p.id,
          p.tripId,
          String(p.amountUsd ?? ''),
          p.status,
          p.method,
          p.provider ?? '',
          p.externalId ?? '',
          (p.createdAt as any)?.toISOString?.() || String(p.createdAt),
          (p.updatedAt as any)?.toISOString?.() || String(p.updatedAt),
          String(p.isAuthorized),
          String(p.isPaid),
          String(p.isFailed),
          p.providerDisplay,
          String(p.capturable),
        ].map(v => `"${String(v).replace(/"/g,'""')}"`).join(','))
        const csv = [header.join(','), ...rows].join('\n') + '\n'
        reply.header('Content-Type','text/csv; charset=utf-8')
        return reply.send(csv)
      }
      const nextCursor = items.length === limit ? items[items.length - 1].id : null
      return reply.send({ items: mapped, nextCursor })
    }
  )

  // Admin payments report (aggregates)
  const reportQuery = {
    type: 'object',
    properties: {
      city: { type: 'string' },
      from: { type: 'string', format: 'date-time' },
      to: { type: 'string', format: 'date-time' },
      groupBy: { type: 'string', enum: ['day','city','status','city_day','method'], default: 'day' },
      format: { type: 'string', enum: ['json','csv'], default: 'json' },
    },
    additionalProperties: false,
  } as const

  app.get(
    '/admin/payments/report',
    { schema: { operationId: 'adminPaymentsReport', tags: ['payments'], summary: 'Reporte de pagos (ADMIN)', description: 'Agregados de pagos por fecha/ciudad/estado/método. Si format=csv, devuelve text/csv.', querystring: reportQuery, response: { 200: { content: { 'application/json': { schema: { type: 'object', properties: { items: { type: 'array', items: { type: 'object', additionalProperties: true } }, totals: { type: 'object', properties: { count: { type: 'integer' }, amountUsd: { type: 'number' } } } }, example: { items: [ { day: '2025-01-01', city: 'GYE', status: 'PAID', count: 12, amountUsd: 45.3 } ], totals: { count: 12, amountUsd: 45.3 } } } }, 'text/csv': { schema: { type: 'string', example: 'day,city,status,count,amountUsd\n2025-01-01,GYE,PAID,12,45.30\nTOTAL,,,12,45.30\n' } } } } } }, preHandler: app.auth.requireRole('ADMIN') },
    async (req: any, reply) => {
      const { city, from, to, groupBy = 'day', format = 'json' } = req.query as { city?: string; from?: string; to?: string; groupBy?: 'day'|'city'|'status'|'city_day'|'method'; format?: 'json'|'csv' }
      const whereParts: string[] = ["p.\"status\" = 'PAID'"]
      const params: any[] = []
      if (from) { whereParts.push('p."createdAt" >= $' + (params.push(new Date(from)))); }
      if (to) { whereParts.push('p."createdAt" <= $' + (params.push(new Date(to)))); }
      if (city) { whereParts.push('t."city" = $' + (params.push(city))); }
      const where = whereParts.length ? ('WHERE ' + whereParts.join(' AND ')) : ''
      let select = ''
      let group = ''
      if (groupBy === 'day') { select = 'date_trunc(\'day\', p."createdAt")::date AS day'; group = 'day'; }
      else if (groupBy === 'city') { select = 't."city" AS city'; group = 'city'; }
      else if (groupBy === 'status') { select = 'p."status" AS status'; group = 'status'; }
      else if (groupBy === 'method') { select = 'p."method" AS method'; group = 'method'; }
      else { select = 'date_trunc(\'day\', p."createdAt")::date AS day, t."city" AS city'; group = 'day, city'; }
      const sql = `
        SELECT ${select}, COUNT(*)::int AS count, COALESCE(SUM(p."amountUsd"),0)::float AS "amountUsd"
        FROM "Payment" p
        LEFT JOIN "Trip" t ON t."id" = p."tripId"
        ${where}
        GROUP BY ${group}
        ORDER BY ${group}
      `
      const rows = await prisma.$queryRawUnsafe<any[]>(sql, ...params)
      // compute totals
      const totals = rows.reduce((acc, r) => { acc.count += Number(r.count || 0); acc.amountUsd += Number(r.amountUsd || 0); return acc }, { count: 0, amountUsd: 0 })
      if (format === 'csv') {
        // determine headers based on groupBy
        const headers = groupBy === 'day' ? ['day','count','amountUsd']
          : groupBy === 'city' ? ['city','count','amountUsd']
          : groupBy === 'status' ? ['status','count','amountUsd']
          : groupBy === 'method' ? ['method','count','amountUsd']
          : ['day','city','count','amountUsd']
        const csvRows = rows.map((r) => headers.map(h => {
          if (h === 'day' && r[h]) {
            try { return new Date(r[h]).toISOString().slice(0,10) } catch { return String(r[h]) }
          }
          if (h === 'amountUsd' && r[h] != null) return Number(r[h]).toFixed(2)
          return r[h] ?? ''
        }).join(','))
        const totalRow = (() => {
          const cols = headers.map((h, idx) => {
            if (h === 'count') return String(totals.count)
            if (h === 'amountUsd') return totals.amountUsd.toFixed(2)
            return idx === 0 ? 'TOTAL' : ''
          })
          return cols.join(',')
        })()
        const csv = [headers.join(','), ...csvRows, totalRow].join('\n') + '\n'
        reply.header('Content-Type','text/csv; charset=utf-8')
        return reply.send(csv)
      }
      return reply.send({ items: rows, totals })
    }
  )

  // Top drivers by revenue (ADMIN)
  const topDriversQuery = {
    type: 'object',
    properties: {
      city: { type: 'string' },
      from: { type: 'string', format: 'date-time' },
      to: { type: 'string', format: 'date-time' },
      limit: { type: 'integer', minimum: 1, maximum: 200, default: 20 },
      format: { type: 'string', enum: ['json','csv'], default: 'json' },
    },
    additionalProperties: false,
  } as const

  app.get(
    '/admin/payments/top-drivers',
    { schema: { operationId: 'adminPaymentsTopDrivers', tags: ['payments'], summary: 'Top drivers por ingresos (ADMIN)', description: 'Ingresos por driver con pagos PAID. Filtra por fecha/ciudad. CSV disponible.', querystring: topDriversQuery, response: { 200: { type: 'object', properties: { items: { type: 'array', items: { type: 'object', properties: { driverId: { type: 'string' }, email: { type: 'string' }, fullName: { type: 'string' }, trips: { type: 'integer' }, amountUsd: { type: 'number' } } } }, totals: { type: 'object', properties: { trips: { type: 'integer' }, amountUsd: { type: 'number' } } } } } } }, preHandler: app.auth.requireRole('ADMIN') },
    async (req: any, reply) => {
      const { city, from, to, limit = 20, format = 'json' } = req.query as { city?: string; from?: string; to?: string; limit?: number; format?: 'json'|'csv' }
      const whereParts: string[] = ["p.\"status\" = 'PAID'"]
      const params: any[] = []
      if (from) { whereParts.push('p."createdAt" >= $' + (params.push(new Date(from)))); }
      if (to) { whereParts.push('p."createdAt" <= $' + (params.push(new Date(to)))); }
      if (city) { whereParts.push('t."city" = $' + (params.push(city))); }
      // require driverId not null
      whereParts.push('t."driverId" IS NOT NULL')
      const where = 'WHERE ' + whereParts.join(' AND ')
      const sql = `
        SELECT t."driverId" AS "driverId",
               u.email AS email,
               (u."firstName" || ' ' || u."lastName") AS "fullName",
               COUNT(*)::int AS trips,
               COALESCE(SUM(p."amountUsd"),0)::float AS "amountUsd"
        FROM "Payment" p
        JOIN "Trip" t ON t."id" = p."tripId"
        JOIN "User" u ON u."id" = t."driverId"
        ${where}
        GROUP BY t."driverId", u.email, u."firstName", u."lastName"
        ORDER BY "amountUsd" DESC
        LIMIT ${Number(limit)}
      `
      const rows = await prisma.$queryRawUnsafe<any[]>(sql, ...params)
      const totals = rows.reduce((acc, r) => { acc.trips += Number(r.trips || 0); acc.amountUsd += Number(r.amountUsd || 0); return acc }, { trips: 0, amountUsd: 0 })
      if (format === 'csv') {
        const headers = ['driverId','email','fullName','trips','amountUsd']
        const csvRows = rows.map(r => headers.map(h => h === 'amountUsd' ? Number(r[h]).toFixed(2) : r[h] ?? '').join(','))
        const totalRow = ['TOTAL','', '', String(totals.trips), totals.amountUsd.toFixed(2)].join(',')
        const csv = [headers.join(','), ...csvRows, totalRow].join('\n') + '\n'
        reply.header('Content-Type','text/csv; charset=utf-8')
        return reply.send(csv)
      }
      return reply.send({ items: rows, totals })
    }
  )

  // Top riders by spend (ADMIN)
  const topRidersQuery = {
    type: 'object',
    properties: {
      city: { type: 'string' },
      from: { type: 'string', format: 'date-time' },
      to: { type: 'string', format: 'date-time' },
      limit: { type: 'integer', minimum: 1, maximum: 200, default: 20 },
      format: { type: 'string', enum: ['json','csv'], default: 'json' },
    },
    additionalProperties: false,
  } as const

  app.get(
    '/admin/payments/top-riders',
    { schema: { operationId: 'adminPaymentsTopRiders', tags: ['payments'], summary: 'Top riders por gasto (ADMIN)', description: 'Gasto por rider con pagos PAID. Filtra por fecha/ciudad. CSV disponible.', querystring: topRidersQuery, response: { 200: { type: 'object', properties: { items: { type: 'array', items: { type: 'object', properties: { riderId: { type: 'string' }, email: { type: 'string' }, fullName: { type: 'string' }, trips: { type: 'integer' }, amountUsd: { type: 'number' } } } }, totals: { type: 'object', properties: { trips: { type: 'integer' }, amountUsd: { type: 'number' } } } } } } }, preHandler: app.auth.requireRole('ADMIN') },
    async (req: any, reply) => {
      const { city, from, to, limit = 20, format = 'json' } = req.query as { city?: string; from?: string; to?: string; limit?: number; format?: 'json'|'csv' }
      const whereParts: string[] = ["p.\"status\" = 'PAID'"]
      const params: any[] = []
      if (from) { whereParts.push('p."createdAt" >= $' + (params.push(new Date(from)))); }
      if (to) { whereParts.push('p."createdAt" <= $' + (params.push(new Date(to)))); }
      if (city) { whereParts.push('t."city" = $' + (params.push(city))); }
      const where = 'WHERE ' + whereParts.join(' AND ')
      const sql = `
        SELECT t."riderId" AS "riderId",
               u.email AS email,
               (u."firstName" || ' ' || u."lastName") AS "fullName",
               COUNT(*)::int AS trips,
               COALESCE(SUM(p."amountUsd"),0)::float AS "amountUsd"
        FROM "Payment" p
        JOIN "Trip" t ON t."id" = p."tripId"
        JOIN "User" u ON u."id" = t."riderId"
        ${where}
        GROUP BY t."riderId", u.email, u."firstName", u."lastName"
        ORDER BY "amountUsd" DESC
        LIMIT ${Number(limit)}
      `
      const rows = await prisma.$queryRawUnsafe<any[]>(sql, ...params)
      const totals = rows.reduce((acc, r) => { acc.trips += Number(r.trips || 0); acc.amountUsd += Number(r.amountUsd || 0); return acc }, { trips: 0, amountUsd: 0 })
      if (format === 'csv') {
        const headers = ['riderId','email','fullName','trips','amountUsd']
        const csvRows = rows.map(r => headers.map(h => h === 'amountUsd' ? Number(r[h]).toFixed(2) : r[h] ?? '').join(','))
        const totalRow = ['TOTAL','', '', String(totals.trips), totals.amountUsd.toFixed(2)].join(',')
        const csv = [headers.join(','), ...csvRows, totalRow].join('\n') + '\n'
        reply.header('Content-Type','text/csv; charset=utf-8')
        return reply.send(csv)
      }
      return reply.send({ items: rows, totals })
    }
  )

  // Summary by payment status (ADMIN)
  const summaryQuery = {
    type: 'object',
    properties: {
      city: { type: 'string' },
      from: { type: 'string', format: 'date-time' },
      to: { type: 'string', format: 'date-time' },
      format: { type: 'string', enum: ['json','csv'], default: 'json' },
    },
    additionalProperties: false,
  } as const

  app.get(
    '/admin/payments/summary-status',
    { schema: { operationId: 'adminPaymentsSummaryStatus', tags: ['payments'], summary: 'Resumen por estado de pago (ADMIN)', description: 'Conteo e importe por estado (PENDING/AUTHORIZED/PAID/FAILED/REFUNDED). CSV disponible.', querystring: summaryQuery, response: { 200: { type: 'object', properties: { items: { type: 'array', items: { type: 'object', properties: { status: { type: 'string' }, count: { type: 'integer' }, amountUsd: { type: 'number' } } } }, totals: { type: 'object', properties: { count: { type: 'integer' }, amountUsd: { type: 'number' } } } } } } }, preHandler: app.auth.requireRole('ADMIN') },
    async (req: any, reply) => {
      const { city, from, to, format = 'json' } = req.query as { city?: string; from?: string; to?: string; format?: 'json'|'csv' }
      const whereParts: string[] = []
      const params: any[] = []
      if (from) { whereParts.push('p."createdAt" >= $' + (params.push(new Date(from)))); }
      if (to) { whereParts.push('p."createdAt" <= $' + (params.push(new Date(to)))); }
      if (city) { whereParts.push('t."city" = $' + (params.push(city))); }
      const where = whereParts.length ? ('WHERE ' + whereParts.join(' AND ')) : ''
      const sql = `
        SELECT p."status" AS status,
               COUNT(*)::int AS count,
               COALESCE(SUM(p."amountUsd"),0)::float AS "amountUsd"
        FROM "Payment" p
        LEFT JOIN "Trip" t ON t."id" = p."tripId"
        ${where}
        GROUP BY p."status"
        ORDER BY p."status"
      `
      const rows = await prisma.$queryRawUnsafe<any[]>(sql, ...params)
      const totals = rows.reduce((acc, r) => { acc.count += Number(r.count || 0); acc.amountUsd += Number(r.amountUsd || 0); return acc }, { count: 0, amountUsd: 0 })
      if (format === 'csv') {
        const headers = ['status','count','amountUsd']
        const csvRows = rows.map(r => [r.status, String(r.count ?? 0), Number(r.amountUsd ?? 0).toFixed(2)].join(','))
        const totalRow = ['TOTAL', String(totals.count), totals.amountUsd.toFixed(2)].join(',')
        const csv = [headers.join(','), ...csvRows, totalRow].join('\n') + '\n'
        reply.header('Content-Type','text/csv; charset=utf-8')
        return reply.send(csv)
      }
      return reply.send({ items: rows, totals })
    }
  )

  // Admin capture of authorized Stripe payments
  app.post(
    '/payments/:tripId/capture',
    { schema: { operationId: 'paymentsCaptureByTrip', tags: ['payments'], summary: 'Capturar pago autorizado (ADMIN)', description: 'Captura un PaymentIntent autorizado de Stripe para el trip.', params: idParamSchema, response: { 200: { type: 'object', properties: { ok: { type: 'boolean' } }, example: { ok: true } }, 400: { type: 'object', properties: { error: { type: 'string' } }, example: { error: 'No hay autorizacion Stripe capturable' } }, 404: { type: 'object', properties: { error: { type: 'string' } }, example: { error: 'Payment no encontrado' } } } }, preHandler: app.auth.requireRole('ADMIN') },
    async (req: any, reply) => {
      const { tripId } = req.params as { tripId: string }
      const payment = await prisma.payment.findUnique({ where: { tripId } })
      if (!payment) return reply.code(404).send({ error: 'Payment no encontrado' })
      if (payment.provider !== 'Stripe' || payment.status !== 'AUTHORIZED' || !payment.externalId) {
        return reply.code(400).send({ error: 'No hay autorizacion Stripe capturable' })
      }
      const { getStripe } = require('../../services/stripe.service')
      const stripe = getStripe()
      const { makeKey, withRetry, reqOpts } = require('../../services/stripe.idempotency')
      if (!stripe) return reply.code(400).send({ error: 'Stripe no configurado' })
      const amountCents = Math.max(1, Math.round(Number(payment.amountUsd as any) * 100))
      try {
        const captured = await withRetry(() => stripe.paymentIntents.capture(
          payment.externalId,
          { amount_to_capture: amountCents },
          reqOpts(makeKey(['admin_capture', tripId, amountCents]))
        ))
        await prisma.payment.update({ where: { tripId }, data: { status: captured.status === 'succeeded' ? 'PAID' : 'AUTHORIZED', externalId: captured.id } })
        return reply.send({ ok: true })
      } catch (e) {
        return reply.code(400).send({ error: 'Captura falló' })
      }
    }
  )

  // Admin refund endpoint
  app.post(
    '/payments/:tripId/refund',
    { schema: { operationId: 'paymentsRefundByTrip', tags: ['payments'], summary: 'Refund/cancel (ADMIN)', description: 'Reembolsa un Payment capturado (Stripe) o cancela autorizacion. Para otros metodos, marca REFUNDED y registra auditoria.', params: idParamSchema, body: { type: 'object', properties: { amountUsd: { type: 'number' }, reason: { type: 'string' } }, additionalProperties: false, example: { amountUsd: 2.5, reason: 'customer_request' } }, response: { 200: { type: 'object', properties: { ok: { type: 'boolean' } }, example: { ok: true } }, 400: { type: 'object', properties: { error: { type: 'string' } }, example: { error: 'No hay autorizacion Stripe capturable' } }, 404: { type: 'object', properties: { error: { type: 'string' } }, example: { error: 'Payment no encontrado' } } } }, preHandler: app.auth.requireRole('ADMIN') },
    async (req: any, reply) => {
      const { tripId } = req.params as { tripId: string }
      const { amountUsd, reason } = (req.body || {}) as { amountUsd?: number; reason?: string }
      const payment = await prisma.payment.findUnique({ where: { tripId } })
      if (!payment) return reply.code(404).send({ error: 'Payment no encontrado' })
      if (payment.status === 'REFUNDED') return reply.code(400).send({ error: 'Ya está REFUNDED' })

      const amount = typeof amountUsd === 'number' && isFinite(amountUsd) && amountUsd > 0 ? Number(amountUsd.toFixed(2)) : Number(payment.amountUsd as any)

      if (payment.provider === 'Stripe' && payment.externalId) {
        const { getStripe } = require('../../services/stripe.service')
      const stripe = getStripe()
      const { makeKey, withRetry, reqOpts } = require('../../services/stripe.idempotency')
        if (!stripe) return reply.code(400).send({ error: 'Stripe no configurado' })
        try {
          if (payment.status === 'PAID') {
            const refund = await withRetry(() => stripe.refunds.create(
              { payment_intent: payment.externalId, amount: Math.max(1, Math.round(amount * 100)) },
              reqOpts(makeKey(['admin_refund', tripId, amount]))
            ))
            await prisma.payment.update({ where: { tripId }, data: { status: 'REFUNDED' } })
            await prisma.paymentRefund.create({ data: { paymentId: payment.id, tripId, amountUsd: amount as any, reason: reason || 'admin_refund', provider: 'Stripe', externalId: refund.id } })
          } else if (payment.status === 'AUTHORIZED') {
            await withRetry(() => stripe.paymentIntents.cancel(
              payment.externalId,
              reqOpts(makeKey(['admin_cancel_auth', tripId]))
            ))
            await prisma.payment.update({ where: { tripId }, data: { status: 'REFUNDED' } })
            await prisma.paymentRefund.create({ data: { paymentId: payment.id, tripId, amountUsd: 0 as any, reason: reason || 'cancel_authorization', provider: 'Stripe', externalId: payment.externalId } })
          } else {
            return reply.code(400).send({ error: 'Estado no reembolsable' })
          }
        } catch (e) {
          return reply.code(400).send({ error: 'Stripe refund/cancel falló' })
        }
      } else {
        // Non-Stripe: mark as REFUNDED and record audit
        await prisma.payment.update({ where: { tripId }, data: { status: 'REFUNDED' } })
        await prisma.paymentRefund.create({ data: { paymentId: payment.id, tripId, amountUsd: amount as any, reason: reason || 'manual_refund', provider: payment.provider || null, externalId: null } })
      }
      return reply.send({ ok: true })
    }
  )

  app.get(
    '/payments/:tripId',
    { schema: { operationId: 'paymentsGetByTrip', tags: ['payments'], summary: 'Obtener pago por tripId', description: 'Devuelve el registro de Payment asociado a un Trip. Requiere JWT y ser dueño del viaje o ADMIN.', params: idParamSchema, response: { 200: paymentSchema, 403: { type: 'object', properties: { error: { type: 'string' } }, example: { error: 'Forbidden' } }, 404: { type: 'object', properties: { error: { type: 'string' } }, example: { error: 'Payment no encontrado' } } } }, preHandler: app.auth.verifyJWT },
    async (req: any, reply) => {
      const user = req.user as { id: string; role: 'ADMIN' | 'DRIVER' | 'RIDER' }
      const tripId = (req.params as any).tripId as string

      const trip = await prisma.trip.findUnique({ where: { id: tripId }, select: { id: true, riderId: true, driverId: true } })
      if (!trip) return reply.code(404).send({ error: 'Trip no encontrado' })
      const isOwner = user.id === trip.riderId || user.id === trip.driverId
      const isAdmin = user.role === 'ADMIN'
      if (!isOwner && !isAdmin) return reply.code(403).send({ error: 'Forbidden' })

      const payment = await prisma.payment.findUnique({ where: { tripId } })
      if (!payment) return reply.code(404).send({ error: 'Payment no encontrado' })
      const isAuthorized = payment.status === 'AUTHORIZED'
      const isPaid = payment.status === 'PAID'
      const isFailed = payment.status === 'FAILED'
      const providerDisplay = payment.provider === 'Stripe' ? 'Stripe' : payment.method === 'CASH' ? 'Cash' : payment.method === 'TRANSFER' ? 'Bank' : (payment.provider || 'Unknown')
      const capturable = payment.provider === 'Stripe' && payment.status === 'AUTHORIZED' && Boolean(payment.externalId)
      return reply.send({
        ...payment,
        isAuthorized,
        isPaid,
        isFailed,
        providerDisplay,
        capturable,
      })
    }
  )

  // Refund audit list by tripId (owner or ADMIN)
  const refundsResponse = {
    type: 'object',
    properties: {
      items: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            id: { type: 'string' },
            paymentId: { type: 'string' },
            tripId: { type: 'string' },
            amountUsd: { type: 'number' },
            reason: { type: 'string', nullable: true },
            provider: { type: 'string', nullable: true },
            externalId: { type: 'string', nullable: true },
            createdAt: { type: 'string', format: 'date-time' },
          },
        },
      },
    },
    example: {
      items: [
        { id: 're_1', paymentId: 'pay_1', tripId: 'trp_1', amountUsd: 1.5, reason: 'admin_refund', provider: 'Stripe', externalId: 're_123', createdAt: '2025-01-01T12:00:00.000Z' }
      ]
    }
  } as const

  // GET /payments/:tripId/receipt (RIDER/DRIVER/ADMIN)
  app.get(
    '/payments/:tripId/receipt',
    { schema: { operationId: 'paymentsReceiptByTrip', tags: ['payments'], summary: 'Obtener recibo', description: 'Recibo simple del pago asociado al viaje. type=TRIP o CANCELLATION_FEE.', params: idParamSchema, response: { 200: { type: 'object', properties: { tripId: { type: 'string' }, amountUsd: { type: 'number' }, currency: { type: 'string' }, method: { type: 'string' }, status: { type: 'string' }, provider: { type: 'string', nullable: true }, type: { type: 'string', enum: ['TRIP','CANCELLATION_FEE'] }, paidAt: { type: 'string', format: 'date-time', nullable: true } }, example: { tripId: 'trp_123', amountUsd: 2.0, currency: 'USD', method: 'CARD', status: 'PAID', provider: 'Stripe', type: 'CANCELLATION_FEE', paidAt: '2025-01-01T12:00:00.000Z' } }, 404: errorSchema } }, preHandler: app.auth.verifyJWT },
    async (req: any, reply) => {
      const tripId = (req.params as any).tripId as string
      const payment = await prisma.payment.findUnique({ where: { tripId } })
      if (!payment) return reply.code(404).send({ error: 'Payment no encontrado' })
      // Infer type from trip status
      const trip = await prisma.trip.findUnique({ where: { id: tripId }, select: { status: true } })
      const type = trip?.status === 'COMPLETED' ? 'TRIP' : 'CANCELLATION_FEE'
      return reply.send({
        tripId,
        amountUsd: Number(payment.amountUsd as any),
        currency: payment.provider === 'Stripe' ? 'USD' : (payment as any).currency || 'USD',
        method: payment.method,
        status: payment.status,
        provider: payment.provider || null,
        type,
        paidAt: payment.status === 'PAID' ? (payment.updatedAt as any) : null,
      })
    }
  )

  app.get(
    '/payments/:tripId/refunds',
    { schema: { operationId: 'paymentsRefundsByTrip', tags: ['payments'], summary: 'Refunds por tripId', description: 'Lista auditorias de reembolso/cancelaciÃ³n del pago de un trip. Requiere JWT y ser dueño del viaje o ADMIN.', params: idParamSchema, response: { 200: refundsResponse, 403: { type: 'object', properties: { error: { type: 'string' } }, example: { error: 'Forbidden' } }, 404: { type: 'object', properties: { error: { type: 'string' } }, example: { error: 'Trip no encontrado' } } } }, preHandler: app.auth.verifyJWT },
    async (req: any, reply) => {
      const user = req.user as { id: string; role: 'ADMIN' | 'DRIVER' | 'RIDER' }
      const { tripId } = req.params as { tripId: string }
      const trip = await prisma.trip.findUnique({ where: { id: tripId }, select: { riderId: true, driverId: true } })
      if (!trip) return reply.code(404).send({ error: 'Trip no encontrado' })
      const isOwner = user.id === trip.riderId || user.id === trip.driverId
      const isAdmin = user.role === 'ADMIN'
      if (!isOwner && !isAdmin) return reply.code(403).send({ error: 'Forbidden' })
      const items = await (prisma as any).paymentRefund.findMany({ where: { tripId }, orderBy: { createdAt: 'desc' } })
      return reply.send({ items })
    }
  )

  // Admin refunds list (global)
  const refundListQuery = {
    type: 'object',
    properties: {
      userId: { type: 'string' },
      city: { type: 'string' },
      from: { type: 'string', format: 'date-time' },
      to: { type: 'string', format: 'date-time' },
      limit: { type: 'integer', minimum: 1, maximum: 200, default: 50 },
      cursor: { type: 'string' },
      format: { type: 'string', enum: ['json','csv'], default: 'json' },
    },
    additionalProperties: false,
  } as const

  const refundItemSchema = {
    type: 'object',
    properties: {
      id: { type: 'string' },
      paymentId: { type: 'string' },
      tripId: { type: 'string' },
      amountUsd: { type: 'number' },
      reason: { type: 'string', nullable: true },
      provider: { type: 'string', nullable: true },
      externalId: { type: 'string', nullable: true },
      createdAt: { type: 'string', format: 'date-time' },
    },
  } as const

  app.get(
    '/admin/refunds',
    { schema: { operationId: 'adminRefundsList', tags: ['payments'], summary: 'Listar refunds (ADMIN)', description: 'Lista auditorias de reembolso/cancelaciÃ³n con filtros y CSV. Si format=csv, devuelve text/csv.', querystring: refundListQuery, response: { 200: { content: { 'application/json': { schema: { type: 'object', properties: { items: { type: 'array', items: refundItemSchema }, nextCursor: { type: 'string', nullable: true } } } }, 'text/csv': { schema: { type: 'string', example: 'id,paymentId,tripId,amountUsd,reason,provider,externalId,createdAt\n"re_1","pay_1","trp_1",1.5,"admin_refund","Stripe","re_123","2025-01-01T12:00:00.000Z"\n' } } } } } }, preHandler: app.auth.requireRole('ADMIN') },
    async (req: any, reply) => {
      const { userId, city, from, to, limit = 50, cursor, format = 'json' } = req.query as { userId?: string; city?: string; from?: string; to?: string; limit?: number; cursor?: string; format?: 'json'|'csv' }
      const where: any = {}
      if (from || to) where.createdAt = { ...(from ? { gte: new Date(from) } : {}), ...(to ? { lte: new Date(to) } : {}) }
      if (userId) {
        // Filter by rider/driver on Trip
        where.trip = { OR: [ { riderId: userId }, { driverId: userId } ] }
      }
      if (city) {
        where.trip = {
          ...(where.trip || {}),
          pricingSnapshot: { path: ['city'], equals: city } as any,
        }
      }

      const items = await prisma.paymentRefund.findMany({
        where,
        take: limit,
        ...(cursor ? { skip: 1, cursor: { id: cursor } } : {}),
        orderBy: { createdAt: 'desc' },
      })

      if (format === 'csv') {
        const header = ['id','paymentId','tripId','amountUsd','reason','provider','externalId','createdAt']
        const rows = items.map((r: any) => [
          r.id,
          r.paymentId,
          r.tripId,
          String(r.amountUsd ?? ''),
          r.reason ?? '',
          r.provider ?? '',
          r.externalId ?? '',
          (r.createdAt as any)?.toISOString?.() || String(r.createdAt),
        ].map(v => `"${String(v).replace(/"/g,'""')}"`).join(','))
        const csv = [header.join(','), ...rows].join('\n') + '\n'
        reply.header('Content-Type','text/csv; charset=utf-8')
        return reply.send(csv)
      }

      const nextCursor = items.length === limit ? items[items.length - 1].id : null
      return reply.send({ items, nextCursor })
    }
  )
}








